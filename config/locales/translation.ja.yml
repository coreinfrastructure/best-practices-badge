---
ja:
  helpers:
    select:
      prompt: 選択してください
    submit:
      create: "%{model} 作成"
      update: "%{model} 更新"
      submit: "%{model} 保存"
  hello: Hello world
  submit: 送信
  projects_count:
    one: "%{count} プロジェクト"
    other: "%{count} プロジェクト"
    zero: 該当プロジェクトなし
    few: "%{count} プロジェクト"
    many: "%{count} プロジェクト"
  feed_title: OpenSSFベストプラクティス バッジ更新プロジェクト
  project_name_unknown: "（名称不明）"
  locale_name:
    en: 英語
    de: ドイツ語
    fr: フランス語
    ja: 日本語
    zh-CN: 中国語 (簡体字)
    ru: ロシア語
    es: スペイン語
    sw: スワヒリ語
    pt-BR: ブラジル系ポルトガル語
  layouts:
    cii_best_practices: OpenSSF ベストプラクティス
    projects: プロジェクト
    users: ユーザー
    account: アカウント
    profile: プロフィール
    settings: 設定
    logout_html: <i class="fa fa-sign-out" aria-hidden="true"></i>ログアウト
    signup_html: <i class="fa fa-user-plus" aria-hidden="true"></i>サインアップ
    login_html: <i class="fa fa-sign-in" aria-hidden="true"></i>ログイン
    footer_text_html: >-
      <small> <strong>疑問、質問、または問題がある場合は<em> <a href="mailto:&#99;ii&#45;badges&#45;questions&#64;lists&#46;coreinfrastructure&#46;or&#103;">電子メールで報告する</a></em>か、<em>
      <a href="https://github.com/coreinfrastructure/best-practices-badge/issues"
      target="_blank" rel="noopener">こちらから問題を提出</a></em>してください。</strong>
      © 2015-2021 <a href="https://openssf.org" target="_blank"
      rel="noopener">Open Source Security Foundation</a>、<a href="https://www.linuxfoundation.org/"
      target="_blank" rel="noopener">Linux Foundation</a> Collaborative
      Project. All Rights Reserved.<a href="https://www.linuxfoundation.org/privacy"
      target="_blank" rel="noopener">プライバシー ポリシー</a> と<a href="https://www.linuxfoundation.org/terms"
      target="_blank" rel="noopener">利用条件</a>を必ずお読みください。</small>
    choose_locale: 言語を選択する
    toggle_navigation: 折りたたみ可能なナビゲーションを切り替える
  account_activations:
    activated: アカウントが有効になりました！
    failed_activation: 無効なアクティベーション リンクです
    delay:
      zero: 今すぐログインできます。アクティベーション後のスパム対策遅延はありません。
      one: スパム対策として、ログインできるまでに、アクティベーション後1時間待つ必要があります。
      few: スパム対策として、ログインできるまでに、アクティベーション後%{count}時間待つ必要があります。
      other: スパム対策として、ログインできるまでに、アクティベーション後%{count}時間待つ必要があります。
  password_resets:
    forgot_password: パスワードを忘れた方はこちら
    reset_password: パスワードをリセットしてください
    password_confirmation: 確認
    password_empty: パスワードを空にすることはできません
    password_reset: パスワードがリセットされました
    instructions_sent: パスワードリセットの方法が電子メールで送信されました（ローカル アカウントが存在する場合）
    reset_expired: パスワードのリセットは期限切れです
    update_password: パスワードを更新してください
  sessions:
    login_header: ログイン
    login_with_github_html: <span class="fa fa-github"></span>
      GitHub でログインする
    or: または
    email: 電子メール
    password: パスワード
    forgot_password: パスワードを忘れた方はこちら。
    remember_me: ログイン状態を保つ（永続化クッキーを使用）
    login_custom: カスタム アカウントを使用してログインする
    no_custom: カスタム アカウントをお持ちでない方はサインアップしてください。
    already_logged_in: あなたは既にログインしています。
    incorrect_login_info: ログイン情報がまちがっています
    invalid_combo: 無効な電子メール・パスワードの組み合わせです
    signed_in: サインインしました！最終ログイン：%{last_login_at}
    not_activated: アカウントが有効化されていません。電子メールでお伝えしたアクティベーション リンクを確認してください。
    signed_out: サインアウトしました！
    cookie_details_html: >-
      <a href="/ja/cookies" target="_blank" rel="noopener"><i>
      Cookieの詳細をご確認ください</i> </a>
    no_login_time: "（前の時間は記録されていません）"
    login_automatic_signup: >-
      GitHubでログインすると、必要に応じてサインアップが自動的に実行されます。サインアップすると、あなたの名前（GitHubに提供されたもの）とGitHubのニックネームが公開され、いつでもあなたの名前を変更することができます。あなたのメールアドレスはプライベートに保たれ、バッジ関連のやりとりにのみ使用されます。法的に要求されている場合を除き、第三者に提供することはありません。
    login_disabled: すべてのログインが一時的に無効になりました
    cannot_login_yet: >-
      申し訳ありませんが、まだログインできません。スパム対策として、ローカルアカウントをアクティベーションした後、ログインできるようになるまでに遅延があります。
  users:
    new:
      signup_header: サインアップ
      intro_html: >-
        GitHubアカウントでログインしたくない場合は、代わりにここでサインアップできます（これにより、メールアドレスを使用してカスタムアカウントが作成されます）。サインアップすると、名前が公開され、いつでも名前を変更できます。あなたのメールアドレスは非公開にされ、バッジ関連のやり取りにのみ使用されます。法的に義務付けられている場合を除き、第三者に提供することはありません。<br><br>アクティベーションリンクが届かない場合は、もう一度サインアップしてください。新しいリンクをお送りします。
      name: 名前
      email: 電子メール
      preferred_locale: 言語・地域
      password: パスワード
      password_confirmation: パスワード（確認のためにもう一度入力してください）
      create_account: カスタム アカウントを作成する
      intro_github: >-
        GitHubアカウントを持っている方は、それを使ってログインできます（最初にGitHubでログインすると、自動的にサインアップされます）。
    edit:
      update_user_info: ユーザー情報を更新します
      save_changes: 変更内容を保存します
      inadequate_privileges: その操作は許可されていません。
    update:
      profile_updated: プロフィールが更新されました
    show:
      edit_user: ユーザーを編集する
      other_projects_edit: GitHubで編集できるその他のプロジェクト：
      see_external: ユーザーの外部ページ。
      as_admin: 管理者として、次の操作を行うこともできます。
      send_email_to: 電子メールを送る
      delete_link_name: ユーザー アカウントを削除する
      confirm_delete: このユーザーを削除してもよろしいですか？
      projects_owned: 所有プロジェクト：
      projects_additional_rights: 追加の権利を持つプロジェクト：
      is_admin: このユーザーはバッジ申請管理者です。
      json_link: JSON
      in_json_format: JSON形式のユーザーデータ（標準のポータブル形式）
      local_account: カスタム（ローカル）アカウント
    destroy:
      cannot_delete_self: 自分を削除することはできません。
      user_deleted: ユーザーが削除されました。
      cannot_delete_user_with_projects: プロジェクトを所有しているユーザーを削除することはできません。
    redirect_existing: そのユーザーは既に存在しています。以前、サインインしたことはありませんか？
    new_activation_link_created: >-
      新しいアクティベーション リンクが作成されました。電子メールを確認してアカウントを有効にしてください。（スパムに対抗するために意図的な遅延があります。）
    please_log_in: ログインしてください。
  project_stats:
    index:
      project_stats_header: プロジェクトの統計
      all_projects: すべてのプロジェクト
      projects_nontrivial: 顕著な進捗状況のプロジェクト
      projects_activity_30: 過去30日以内にバッジ申請を行ったプロジェクト
      daily_activity: 毎日のバッジ申請状況
      reminders: リマインダー
      active_projects: 活動中プロジェクト（30日以内に登録/更新）
      active_in_progress: 進行中のプロジェクト（30日以内に登録/更新）
      active_edited: 編集作業中プロジェクト（30日以内に更新）
      active_edited_in_progress: 編集作業中の進行中プロジェクト（30日以内に更新）
      projects_created_since_yesterday: 前日以降のプロジェクト登録数
      projects_updated_since_yesterday: 前日以降のプロジェクト更新数
      projects_created_average_7_days: プロジェクト登録数の7日間平均
      projects_updated_average_7_days: プロジェクト更新数の7日間平均
      reminders_sent_since_yesterday: 昨日以降に送信されたリマインダー
      reactivated_projects: リマインダー受信後14日以内に再活性化したプロジェクト
      admin_html: >-
        管理者は、<a href="/ja/reminders">リマインダーに関する詳細情報</a>や<a href="/ja/project_stats?type=uncommon">あまり使われていない統計情報のグラフ</a>も参照できます。
      raw_data: 生データを見ることもできます：
      json_format: JSON形式
      csv_format: ダウンロード可能なCSV形式
      projects_created_updated_daily: >-
        「前日以降のプロジェクト登録数」というデータは、指定された日時から24時間以内に登録されたプロジェクトの数です（同じ24時間内に削除されたプロジェクトは含まれません）。同様に、「前日以降に編集されたプロジェクト」というデータは、指定された日時から24時間以内に編集されたプロジェクトの数です（24時間以内に作成または削除されたプロジェクトは含まれません）。
        7日間平均は、対応するデータの7日間平均値を示す。凡例で色を選択して、対応するデータを非表示にすることができます。
      projects_silver: シルバーを目指すプロジェクト進捗状況
      projects_gold: ゴールドを目指すプロジェクト進捗状況
      projects_completed_silver_and_gold: シルバーとゴールドを達成したプロジェクト
      percent_projects_earning_badges: バッジを獲得したプロジェクトの割合
      users: ユーザー
      github_users: GitHubユーザー
      local_users: カスタム（ローカル）ユーザー
      users_created_since_yesterday: 昨日以降に作成されたユーザー
      users_updated_since_yesterday: 昨日以降に更新されたユーザー
      users_with_projects: プロジェクトのユーザー
      users_without_projects: プロジェクトのないユーザー
      users_with_multiple_projects: 複数のプロジェクトを持つユーザー
      users_with_passing_projects: 合格プロジェクトのユーザー
      users_with_silver_projects: シルバープロジェクトのユーザー
      users_with_gold_projects: ゴールド・プロジェクトのユーザー
      user_statistics: ユーザー統計
  projects:
    index:
      add_link: 追加
      add_new: プロジェクトを追加
      badge_status: バッジ ステータス
      exclude_passing: 合格プロジェクトを除外する
      text_search: テキスト検索
      name_or_description: 名前または説明文
      search: 検索
      all: すべて
      passing_100: 少なくとも合格（100％+ tiered）
      in_progress_variable: 進行中（%{percent}％+ tiered）
      silver_in_progress_variable: 合格、部分的なシルバー（%{percent}％+ tiered）
      silver_200: シルバー（200％+ tiered）
      gold_in_progress_variable: シルバー、部分的なゴールド（%{percent}％+ tiered）
      gold_300: ゴールド（300％）
      in_progress_next: 進行中、合格に向けて%{percent}が完了しました
      passing_next: 進行中、シルバーに向けて%{percent}が完了しました
      silver_next: シルバー、ゴールドに向けて%{percent}が完了しました
    table:
      id: ID
      name: 名称
      description: 概要
      website: ウェブサイト
      license: ライセンス
      owner: オーナー
      last_achieved: 最終達成日時
      pachieved: 達成率
      can_also_sort: >-
        「達成率」フィールドには、ゴールドが300％、シルバーが200％、パスが100％と表示され、獲得した最も高レベルのバッジの後に進行状況が追加されます。次のようにソートすることもできます。
      repository_url: リポジトリのURL
      create_time: 作成日時 (バッジ エントリの)
      update_time: 最終更新日時（バッジ エントリの）
      user_id: ユーザーID
      paren_name_unknown: "（名前不明）"
      badge_level: プロジェクト %{id} のバッジレベルは %{percent}％ です
      badge: バッジ
    new:
      post_delay_warning: 自動的に情報を入力しようとするため、送信後にかなりの遅れが生じることがあります。
      new_badge: 新しいバッジ
      may_select_html: >-
        GitHubリポジトリの1つを選択する、<em>または</em>他のプロジェクトの情報を提供することができます。プロジェクトが合格バッジを獲得しておらず、30日以上編集を行っていない場合は、リマインダー
        メールが送信されます（必要に応じていつでもリマインダーを無効にできます）。
      select_one_github: GitHub リポジトリを選択してください
      submit_github: GitHubリポジトリを送信する
      url_of_homepage: >-
        プロジェクトのホームページ（プロジェクト全体のURL）のURLは何ですか？ http（s）：//で始まります（「？」を含め、多くの使用できない文字があります）。
      placeholder_of_homepage: http(s)://... プロジェクトのホームページのURLには、できるだけ
        https:// を使用してください
      url_of_repo: バージョン管理リポジトリのURLは何ですか（プロジェクトURLと同じでもかまいません）。
      placeholder_of_repo: http(s)://... プロジェクト リポジトリのURLには、できるだけ
        https:// を使用してください
      submit_urls: URLを送信する
      sign_in_first: プロジェクトを追加するにはログインしてください！
      thanks_adding: プロジェクトを追加していただきありがとうございます！バッジを取得するには、残りの情報を入力してください。
      project_already_exists: このプロジェクトは既に存在します！
      final_text_html: >-
        注 - リポジトリURLがGitHub上にある場合、リポジトリにコミットできる人は誰でもバッジ情報を編集できるようになるでしょう。
      new_badge_or: または
      original_repos: "=>オリジナルのGitHubリポジトリ"
      fork_repos: "=>フォークされたGitHub リポジトリ"
      tell_us: >-
        あなたのfree / libre / open source software（FLOSS）プロジェクトについて教えてください。これはFLOSSプロジェクトで<b>なければなりません</b>
        。他のものは許可されていません。サイトの検索エンジン最適化（SEO）を改善するために、無関係なサイトを追加<b>しない</b>でください。このスパムは、ユーザーに害を与えるため禁止されていますし、SEOには役に立ちません（すべてのハイパーリンクには<tt>ugc</tt>と<tt>nofollow</tt>のマークが付いています）。
    show:
      edit: 編集
      delete: 削除
      confirm_delete: あなたは、全プロジェクト%{project_id}を削除しようとしていますが、よろしいでしょうか？
      back: もどる
      cc_by_3plus_html: >-
        このデータは、<a href="https://creativecommons.org/licenses/by/3.0/us"
        target="_blank" rel="noopener">Creative Commons Attribution
        version 3.0以降のライセンス（CC-BY-3.0 +）</a>のもとで利用できます。すべての人がデータを自由に共有および適応できますが、適切にクレジットを入れる必要があります。
        %{user}とOpenSSFベストプラクティス バッジ貢献者のクレジットを入れてください。<br><br>
      cc_by_3only_html: >-
        本データは、<a href="https://openssf.org/" target="_blank" rel="noopener">Open
        Source Security Foundation</a> <a href="https://www.linuxfoundation.org/terms"
        target="_blank" rel="noopener">利用規約</a>に従って、<a href="https://creativecommons.org/licenses/by/3.0/us"
        target="_blank" rel="noopener">Creative Commons Attribution
        version 3.0 ライセンス（CC-BY-3.0）</a>のもとで利用できます。すべての人が自由にデータを共有し、修正することができますが、適切にクレジットを入れなければなりません。%{user}とOpenSSF
        ベストプラクティス バッジ貢献者のクレジットを入れてください。<br> <br>
      owned_by: プロジェクト バッジ登録の所有者：
      created_at_html: "<strong>エントリの作成日時</strong> %{when}、"
      updated_at_html: "<strong>最終更新日</strong> %{when}"
      last_lost_html: 最後に%{when}にバッジ合格できませんでした。
      last_achieved_html: 最後に%{when}にバッジ合格を達成しました。
      cdla_permissive_20_html:
    edit:
      submit_cc_by_3plus_html: >-
        プロジェクトに関するこのデータを送信することにより、少なくとも、<a href="https://creativecommons.org/licenses/by/3.0/us"
        target="_blank" rel="noopener">Creative Commons Attribution
        version 3.0以降（CC-BY-3.0 +）</a>のライセンス条件によって公開することに同意したことになります。つまり、すべての人が自由にデータを共有し、修正することができますが、適切なクレジットを入れる必要があります。あなたが保有する著作権に影響はありません。プロジェクトライセンスにも影響はありません。<br>
        <br>
      save_and_continue: 保存する（そして続行する）
      submit_and_exit: 送信（および終了）
      repo_url_limits: >-
        repo_urlを変更できるのは、(1) 最後に変更してから180日以上経過している場合、または、(2) httpとhttpsを切り替える場合のみです。もっと早く変更する必要がある場合は、issue
        を提出して（根拠を示して）ください。
      changed_since_html: >-
        別のユーザーが、編集フォームにアクセスして、そのレコードに変更を加えました。 <br>変更を送信するには、新しい<a
        href="%{edit_url}" target="_blank" rel="noopener">編集フォーム</a>を開いてください。
      successfully_updated: プロジェクトは正常に更新されました
      congrats_new: >-
        %{new_badge_level}バッジ獲得、おめでとうございます！まだ表示を行っていないければ、プロジェクトのバッジステータスをプロジェクトページに表示してください（その方法は、下の「表示の方法」のテキストをご覧ください）。
      lost_badge: プロジェクトはバッジを失いました
      static_analysis_updated_html: 基準 static_analysis の要件を更新しました。この基準の正当性を追加してください。
      edit_status: プロジェクトのバッジステータスを表示する
      submit_cdla_permissive_20_html:
    form_basics:
      project_name:
        description: プロジェクトの名前は何ですか？
        details: 他のプロジェクトが同じ名前を使用していないか注意してください。
        placeholder: FLOSSプロジェクト名
      description:
        description: プロジェクトを簡単に説明してください。
        details: >-
          プロジェクトに関して鍵となるコメントを含めてください。Markdown書式を使用します。この情報は、バッジ情報を表示するときに使用されます。
        placeholder: プロジェクトの説明
      homepage_url:
        description: プロジェクト全体のURLは？
        placeholder: プロジェクトWebサイトのURL
      repo_url:
        description: バージョン管理リポジトリのURLは何ですか（プロジェクトURLと同じでもかまいません）。
        placeholder: プロジェクトのリポジトリURL
      implementation_languages:
        description: どのようなプログラミング言語を使ってプロジェクトを実装していますか？
        details: >-
          複数の言語がある場合は、コンマを区切り（スペースを入れてもよい）としてリストし、使用頻度の高いものから順に並べます。使用言語が多くある場合は、少なくとも最初の3つの最も多く使われるものをリストアップしてください。言語がない場合（例：ドキュメントだけ、またはテスト専用のプロジェクトの場合）、1文字
          " - "を使用します。言語ごとにある大文字・小文字の慣用を踏襲してください（例：「JavaScript」）。
        placeholder: 使用された実装言語（コンマで区切られたリスト、使用量によってソート）
      cpe:
        description_html: >-
          プロジェクトの<a href="https://nvd.nist.gov/cpe.cfm"> Common
          Platform Enumeration（CPE）</a>名は何ですか？
        details_html: >-
          <a href="https://nvd.nist.gov/cpe.cfm"> Common Platform
          Enumeration（CPE）</a>は、情報技術（IT）システム、ソフトウェア、およびパッケージのための構造化された命名体系です。脆弱性を報告する際に、多くのシステムやデータベースで使用されています。
        placeholder: "（オプション）CPE名"
      license:
        description_html: プロジェクトのライセンスはどのようなものですか？
        details_html: >-
          <a href="https://spdx.org/licenses/"> SPDXライセンスの表現形式</a>を使用してください。
          例：「Apache-2.0」、「BSD-2-Clause」、「BSD-3-Clause」、「GPL-2.0+」、「LGPL-3.0+」、「MIT」、「(BSD-2-Clause
          OR Ruby)」。一重引用符または二重引用符を<b>含めない</b>でください。
        placeholder: FLOSSライセンス
        title: >-
          SPDXライセンス表現形式のライセンス（例： "MIT"または "GPL-3.0 +"、シングル引用符や二重引用符を付けない）
      additional_rights_changes:
        description: |-
          （詳細）このバッジエントリを編集する権限を持つユーザーは？
          現在：%{current_rights}
        details_html: >-
          ほとんどのプロジェクトはこのフィールドを無視するべきです。プロジェクトのバッジエントリは、バッジエントリのオーナー（作成者）、BadgeApp管理者、GitHubリポジトリにコミットできる人（GitHub上にある場合）によっていつでも編集できます。他の人がこのバッジエントリを編集できるようにする必要があり、あなたがこのプロジェクトのバッジ
          エントリの編集権限をすでに持っている場合は、編集権限を持つ追加のユーザを追加することができます。"+"と入力し、その後にカンマ区切りの整数ユーザーIDのリストを入力します。そうすることで、これらのユーザーも、このプロジェクト
          エントリを編集できるようになります。あなたがバッジ エントリのオーナーまたはBadgeApp管理者である場合は、"-"と入力した後にカンマで区切られた整数ユーザーIDのリストを入力すれば、このリストからユーザーを削除できます。通常、特定のバッジエントリを一度に編集するのは1人だけであると予想されます。複数のユーザーが同時に編集しようとすると、このアプリケーションはオプティミスティック
          ロック機能を使用して古いデータを保存しないようにします。複数の編集者がいる場合は、バッジ エントリ データを段階的かつ頻繁に保存することをお勧めします（いずれにしてもこれは賢明な方法です）。
        placeholder:  "+"または"-"の後にコンマで区切られたユーザーIDのリストを入力して変更する
    form_early:
      badge_intro:
        description: >-
          本サイトが提示する下記のベストプラクティスを実行するプロジェクトは、Open Source Security
          Foundation (OpenSSF) バッジを達成したことを自主的に自己認証し、そのことを外部に示すことができます。
        details_html: >-
          ソフトウェアに欠陥や脆弱性がないことを保証する手立てはありません。形式論的な証明ができたとしても、仕様や前提が間違っていると誤動作の可能性があります。また、プロジェクトが健全で、かつ機能的な開発コミュニティであり続けることを保証する手立てもありません。しかし、ベストプラクティスの採用は、プロジェクトの成果の向上に寄与する可能性があります。たとえば、いくつものベストプラクティスがリリース前の複数人によるレビューを定めていますが、それによりレビュー以外では発見困難な技術的脆弱性を見つけるのを助け、同時に異なる企業の開発者間の信頼を築き、さらに交流を続けることに対する意欲を生んでいます。バッジを獲得するには、すべてのMUSTおよびMUST
          NOT基準を満たさなければなりません。すべてのSHOULD基準も満たさなければなりませんが、正当な理由がある場合は満たさなくても構いません。<em>そして</em>すべてのSUGGESTED基準も満たさなければなりませんが、満たさないとしても、少なくとも考慮することが望まれます。フィードバックは、<a
          href="https://github.com/coreinfrastructure/best-practices-badge">
          GitHubサイトのissueまたはpull request</a>として提示されれば歓迎します。また、<a
          href="https://lists.coreinfrastructure.org/mailman/listinfo/cii-badges">議論のためのメールリスト</a>も用意されています。<br
          /> <br />私たちは多言語で情報を提供していますが、翻訳版に矛盾や意味の不一致がある場合は、英語版を正式な記述とします。
      got_badge:
        description_1: >-
          これがあなたのプロジェクトなら、あなたのプロジェクトページにあなたのバッジステータスを表示してください！バッジステータスは次のようになります。
        description_2: バッジステータスの埋め込み方法は次のとおりです。
        details_html: >-
          バッジステータスを表示するには、あなたのプロジェクトのマークダウンファイルに以下を埋め込みます<br />
          %{markdown_embedding} <br />あるいは、以下をHTMLに埋め込みます<br />
          %{html_embedding} <br />
        editing_description_html: >-
          作業中のデータを保存するには、<strong>頻繁に「提出」</strong>してください（いつでも戻って編集作業を続けることができます）。
          <br> <br>ヘルプが必要な場合、質問がある場合、あるいは問題がある場合は、<em> <a href="mailto:&#99;ii&#45;badges&#45;questions&#45;own&#101;r&#64;lists&#46;coreinfrastructure&#46;or&#103;">電子メールを送信する</a></em>か<em>
          <a href="https://github.com/coreinfrastructure/best-practices-badge/issues"
          target="_blank" rel="noopener">問題を提起</a> </em>します。
        badge_alt: プロジェクト %{id} のバッジ レベルは %{level} です
      level:
        0_html: これらは%{passing}レベルの基準です。%{silver}または%{gold}レベル基準を表示することもできます。
        1_html: これらは%{silver}レベルの基準です。%{passing}または%{gold}レベル基準を表示することもできます。
        2_html: これらは%{gold}レベルの基準です。%{passing}または%{silver}レベル基準を表示することもできます。
        '0': 合格
        '1': シルバー
        '2': ゴールド
    misc:
      disabled_reminders: >-
        （詳細）非アクティビティ リマインダーを無効にします（このままにしておくことをお勧めします。リマインダーを送信するかどうかを変更するには、プロジェクトエントリーを編集する必要があります。）
      general_comments:
        description: プロジェクトに関するその他の一般的なコメント
        placeholder: 追加コメント（マークダウンで）
      some_not_crypto_html: >-
        一部のソフトウェアは暗号化メカニズムを使用する必要がないことに注意してください。あなたのプロジェクトが作成するソフトウェアが、(1)
        暗号化機能を含む、アクティブ化する、または有効化し、(2) 米国（US）から米国外または米国市民以外にリリースされる可能性がある場合は、法的に義務付けられた追加手順の実行を要求される可能性があります。通常、これにはメールの送信が含まれます。詳細については、
        <a href="https://www.linuxfoundation.org/resources/publications/understanding-us-export-controls-with-os-projects/"
        ><i>Understanding Open Source Technology &amp; US Export
        Controls</a>（<a href="https://www.linuxfoundation.jp/publications/2020/07/understanding-open-source-technology-us-export-controls/">「オープンソース技術と米国の輸出管理について」</a>）の暗号化のセクションを参照してください。
      dont_use_crypto: プロジェクトで開発されるソフトウェアが暗号化メカニズムを使用していない場合は、ここをクリックしてください
      future_header_html: |-
        近い将来に追加予定のバッジ基準ですが、現在のところバッジに
        <em>必須ではありません </em>。ベストプラクティスのバッジ基準が強化されるまでの本猶予期間は、プロジェクトが変更された基準に沿って更新し、それまでの間バッジを保持することを可能にします。
      in_javascript:
        collapse_all_title: すべてのパネルを折りたたむ
        collapse_all: パネルを折りたたむ
        expand_all_title: すべてのパネルを展開
        expand_all: パネルを展開
        show_details: 詳細を表示
        hide_details: 詳細を非表示
        show_all_details: 詳細をすべて表示
        hide_all_details: 詳細をすべて非表示
        show_met_title: 適合した基準と該当しない基準を表示
        show_met_html: 適合したものと該当しないものを表示
        hide_met_title: 適合した基準と該当しない基準を非表示（適合しないものと不明なものは表示）
        hide_met_html: 適合したものと該当しないものを非表示
        passing_alt: バッジには十分です！
        barely_alt: かろうじてバッジには十分です。
        failing_alt: バッジには不十分です。
        unknown_alt: 必須情報が不明、バッジに十分ではありません。
        met_url_placeholder: "（URLが必要）これにどのように適合したか、1つ以上の主要なURLを含めて、説明してください"
        met_justification_placeholder: "（必須）これにどのように適合したか、可能であれば1つ以上の主要なURLを含めて、説明してください"
        met_placeholder: "（オプション）これにどのように適合したか、可能であれば1つ以上の主要なURLを含めて、説明してください"
        unmet_placeholder: これに適合していなくてもなぜ大丈夫なのか、1つ以上の主要なURLを含めて説明してください。
        na_justification_placeholder: "（必須）これがなぜ該当しないのか、可能であれば1つ以上の主要なURLを含めて、説明してください"
        na_placeholder: "（オプション）これがなぜ該当しないのか、可能であれば1つ以上の主要なURLを含めて、説明してください"
        unknown_placeholder: 説明してください
      toggle_details_title: 詳細テキストを切り替えます
      details: 詳細
      url_required: URLが必要です
      future_criterion: 今後追加されるバッジ基準
      url_required_warning: 警告：URLが必要ですが、URLは見つかりません。
      justification_required_warning: 警告：もっと長い正当性が必要です。
      in_development_warning_html: "<strong>警告！</strong>これは本番システムではありません。これはテスト段階です。"
      close: クローズ
    delete:
      done: プロジェクトは正常に削除されました
    delete_form:
      info_html: >-
        <b>警告</b>  -  %{project_name}のバッジエントリを<b>完全に削除</b>しようとしています。これは簡単に元に戻すことが<b>できない</b>ため、このバッジのエントリを削除<b>しない</b>ことをおすすめします。バッジ基準を一度に完了する必要はありません。ほとんどのプロジェクトでは、時間の経過とともに、達成していない基準を特定し、満たすことによってバッジを取得します。いくつかの基準が意味をなさないと思っている場合、いくつかの基準を満たす方法を理解できない、またはその他の質問がある場合は、お問い合わせください。（いくつかの基準は、満たされるべきであるか、単に提案されているだけのものであり、）バッジを取得するために、すべての基準が満たされている必要はありません。リマインダを電子メールで送信しないようにするには、単にプロジェクトエントリを編集し、電子メールリマインダーをオフにします。ただし、このバッジのエントリを<i>完全に削除</i>することを<i>確認</i>している場合は、永久に削除する理由を以下に説明してください。
      rationale_placeholder: >-
        （必須）このプロジェクトバッジのエントリを永久に削除する理由を説明してください。また、代わりに私たちにしてほしいことがあれば記入してください。（20文字以上。空白文字以外で15文字以上）。
      delete_action: このプロジェクトバッジのエントリーを永久に削除してください！
      too_short: 少なくとも20文字以上必要です。
      more_non_whitespace: 少なくとも15文字の空白以外の文字が必要です。
  report_mailer:
    new_project_heading: ベストプラクティス バッジ プログラムにプロジェクトを追加してくださり、ありがとうございます
    new_project_part1: |-
      ベストプラクティス バッジ プログラムに
      あなたのプロジェクトを追加してくださり、ありがとうございます
      このプロジェクトの現在の名前は次のとおりです。
    new_project_part2: |-
      バッジ エントリーにアクセスしてください。
      情報を完成させてバッジを手に入れましょう！
      バッジ エントリのURLは次のとおりです。
    new_project_part3_html: |-
      <p>
      常に進歩しましょう。
      </p>
      <p>
      不足しているもの<em>のみ</em>見たい場合は、
      バッジ エントリにアクセスし、
      上部にある「適合したものと該当しないものを非表示」というラベルの付いたボタンをクリックします。
      ご不明な点がある場合、またはサポートが必要な場合は、以下までお問い合わせください。
      <a href="mailto:&#99;ii&#45;badges&#45;questions&#45;own&#101;r&#64;lists&#46;coreinfrastructure&#46;or&#103;">&#99;ii&#45;badges&#45;questions&#45;own&#101;r&#64;lists&#46;coreinfrastructure&#46;or&#103;</a>
      または以下でissueを提出します
      <a href="https://github.com/coreinfrastructure/best-practices-badge/issues">https://github.com/coreinfrastructure/best-practices-badge/issues</a>
      （"new issue"をクリックしてください）。
      </p>
      <p>
      私たちはあなたに広告を送ることは決してありません。また、電子メールを送ることもめったにありません。
      新しいプロジェクトバッジエントリを作成したとき、プロジェクトがバッジを取得または失ったとき、誰かがユーザーアカウントでパスワードのリセットを要求したときなど、重要なバッジアプリケーションイベントについてメールを送信します。
      プロジェクトにバッジがなく、バッジエントリを30日以上更新していない場合、通常は30〜60日ごとに非アクティブのリマインダーが送信されます。
      これらの非アクティブリマインダーメッセージはいつでも無効にできます。
      <a href="%{project_info_url}#project_disabled_reminders">％{project_info_url} #project_disabled_reminders</a> でバッジエントリを編集するだけです。
      「非アクティブリマインダーを無効にする」をオンにします。
      値を変更する場合は、プロジェクトエントリを<i>編集</i>することを忘れないでください。
      プロジェクトが合格バッジを獲得した場合、またはバッジエントリが30日以内に編集された場合、非アクティブのリマインダーは送信されません。
      </p>
      <p>
      ご協力ありがとうございます。
      </p>
    new_project_part3_text: |-
      進歩を続けることをお勧めします。
      不足しているものだけを確認したい場合は、バッジエントリにアクセスして、
      次に、上部にある「適合したものと該当しないものを非表示」というラベルの付いたボタンをクリックします。
      ご不明な点がある場合、またはサポートが必要な場合は、以下までお問い合わせください
      cii-badges-questions@lists.coreinfrastructure.org
      または以下でissueを提出してください。
      https://github.com/coreinfrastructure/best-practices-badge/issues
      （"new issue" をクリックしてください。）
      私たちはあなたに広告を送ることは決してありません。また、電子メールを送ることもめったにありません。
      重要なバッジ申請イベントについてのメールはお送りします。
      たとえば、新しいプロジェクトバッジエントリを作成するときや、
      あなたのプロジェクトがバッジを取得したときや失ったとき、
      または誰かがあなたのユーザーアカウントでパスワードのリセットを要求したときなどです。
      バッジ エントリを更新し続ける場合、リマインダーは送信されません。
      また、リマインダーは約30〜60日ごとに送信されます。なお、
      これらのリマインダー メッセージを無効にする場合は、次のバッジ エントリを編集し、
      %{project_info_url} #project_disabled_reminders
      「非アクティブ リマインダーを無効にする（desable inactivity reminder）」をオンにします。
      非アクティブのリマインダーを受け取るかどうかを変更する場合は、
      プロジェクト エントリを表示するだけでなく、必ず編集してください。
      プロジェクトが合格バッジを獲得した場合、または
      バッジエントリが30日以内に編集された場合は、
      非アクティブのリマインダーは送信されません。
      ご協力ありがとうございます。
    in_markdown_add: マークダウンでは、これを追加することができます：
    in_html_add: HTMLでは、これを追加することができます：
    ending: "--- David A. Wheeler、OpenSSF Best Practices Badge
      代表"
    subject_achieved_passing: "%{new_level}ベストプラクティス バッジを達成したことをお祝いします！"
    subject_no_longer_passing: あなたのベストプラクティス バッジはもはや%{old_level}ではありません
    subject_new_project: あなたは、OpenSSFベストプラクティス バッジ プログラムにプロジェクトを追加しました
    subject_reminder: あなたのプロジェクトはまだ「ベストプラクティス」バッジを持っていません
    subject_project_deleted: "%{project_name}という名前のプロジェクト%{project_id}を削除されました"
    gained_level_part1: |-
      おめでとうございます！
      あなたが提供した情報によると、
      あなたのプロジェクトはOpenSSFベストプラクティス '%{new_level}'バッジを獲得しました。
      詳細については、次のURLを参照してください。
    gained_level_part2: |-
      バッジをプロジェクトやリポジトリサイトに追加してください。
      あなたはそれを獲得しました：
    gained_level_part3: |-
      正当性についてのテキストを追加または改善することを強くお勧めします。
      より多くの情報を指すURLを追加することも含まれます。
      基準またはバッジ ウェブ アプリケーションを改善する方法の提案がある場合、
      以下で課題を提出してください：
      https://github.com/coreinfrastructure/best-practices-badge/issues
      バッジを取得するためにプロジェクトを変更した場合は、お知らせください
      電子メール：cii-badges-questions@lists.coreinfrastructure.org
      私たちの目標の1つは、プロジェクトの改善を促すことです。
      これらのレポートのいくつかを公開Wikiに載せます。
      変更内容を以下のサイトで公開したくない場合はお知らせください。
      https://github.com/coreinfrastructure/best-practices-badge/wiki/Impacts
      ありがとうございます、そして、おめでとうございます。
    lost_level_message: |-
      申し訳ありませんが、あなたのプロジェクトは「%{old_level}」バッジを有しておらず、現在は「%{new_level}」を有しています。
      詳細については、次のURLを参照してください。
    reminder_body_html: |-
      <h1>%{project_name} に関するベストプラクティス バッジ自動通知</h1>
      <p>
      これは自動通知です。あなたのプロジェクト
      "%{project_name}"
      は、現在、「ベストプラクティス」バッジを取得しておらず、
      また、そのバッジ エントリーがしばらく更新されていません。
      </p>
      <p>
      あなたのベストプラクティスのバッジエントリーは
      <a href="%{project_info_url}">%{project_info_url}</a>
      です。%{project_updated_at}に最後に更新されました。
      現在、%{project_badge_percentage_0}％（100％のうち）です。
      </p>
      <p>
      私たちはあなたが進歩し続けることをお勧めします。
      バッジのエントリー
      <a href="%{project_info_url}">%{project_info_url}</a>
      にアクセスしてください。
      情報を完成させてバッジを手に入れましょう！
      </p>
      <p>
      欠落しているもの<em>のみ</em>を確認したい場合は、バッジのエントリーにアクセスし、
      上部の「すべてのパネルを展開」と表示されているボタンを選択し、
      次に、「適合したものと該当しないものを非表示」というラベルの付いた上部のボタンを選択します。
      ご不明な点がございましたら、以下にお気軽にお問い合わせください。
      <a href="mailto:&#99;ii&#45;badges&#45;questions&#45;own&#101;r&#64;lists&#46;coreinfrastructure&#46;or&#103;">&#99;ii&#45;badges&#45;questions&#45;own&#101;r&#64;lists&#46;coreinfrastructure&#46;or&#103;</a>
      または、以下でissueを提出してください
      <a href="https://github.com/coreinfrastructure/best-practices-badge/issues"> https://github.com/coreinfrastructure/best-practices-badge/issues</a>
      （"new issue"をクリックしてください）。
      </p>
      <p>
      バッジエントリーの更新を続行してもリマインダーは送信されませんが、
      おおよそ30〜60日おきにリマインダーを送信します。なお、
      これらのリマインダー メッセージを無効にする場合は、以下でバッジ エントリーを編集してください。
      <a href="%{project_info_url}#project_disabled_reminders">%{project_info_url}#project_disabled_reminders</a>
      「非アクティブ リマインダーを無効にする（desable inactivity reminder）」をオンにします。
      非アクティブのリマインダーを受け取るかどうかを変更する場合は、
      プロジェクト エントリを表示するだけでなく、必ず編集してください。
      リマインダーを受け取らなくても、今後も継続的に活動に取り組み、
      最終的にバッジを獲得してください。
      </p>
      <p>
      ご協力ありがとうございます。
      </p>
    reminder_body_text: |-
      これは自動化リマインダーです。あなたのプロジェクト
      「%{project_name}」
      には現在、「ベストプラクティス」バッジはありません。
      また、バッジ エントリはしばらく更新されていません。
      ベストプラクティスのバッジエントリは次の場所にあります
      %{project_info_url}
      最終更新日は%{project_updated_at}です。
      現在、%{project_badge_percentage_0}％（100％中）です。
      進歩を続けることをお勧めします。
      次のバッジ エントリにアクセスしてください。
      %{project_info_url}
      情報を完成させてバッジを取得しましょう！
      不足しているものだけを確認したい場合は、バッジ エントリにアクセスしてください。
      「すべてのパネルを展開」というラベルの付いた上部近くのボタンを選択し、
      次に、上部にある「適合したものと該当しないものを非表示」というラベルの付いたボタンを選択します。
      ご不明な点がある場合、またはサポートが必要な場合は、以下までお問い合わせください。
      cii-badges-questions@lists.coreinfrastructure.org
      または、以下にissueを提出してください。
      https://github.com/coreinfrastructure/best-practices-badge/issues
      （"new issue" をクリックしてください。）
      バッジ エントリを更新し続ける場合、リマインダーは送信されません。
      また、リマインダーは約30〜60日ごとに送信されます。なお、
      これらのリマインダー メッセージを無効にする場合は、次のバッジ エントリを編集し、
      %{project_info_url} #project_disabled_reminders
      「非アクティブ リマインダーを無効にする（desable inactivity reminder）」をオンにします。
      非アクティブのリマインダーを受け取るかどうかを変更する場合は、
      プロジェクト エントリを表示するだけでなく、必ず編集してください。
      リマインダーを受け取らなくても、今後も継続的に活動に取り組み、
      最終的にバッジを獲得してください。
      ご協力ありがとうございます。
  user_mailer:
    account_activation:
      before_html: |-
        <h1> OpenSSFベストプラクティス バッジ プログラム</h1>
        <p>こんにちは、</p>
        <p>
        このバッジ プログラムへようこそ！
        下のリンクをクリックしてアカウントを有効にしてください。
        </p>
      before_text: |-
        こんにちは、
        OpenSSFベストプラクティス バッジ プログラムへようこそ！
        アカウントを有効にするには、以下のリンクを選択してください。
      activate: アクティベート
      subject: アカウントの有効化
    github_welcome:
      before_html: |-
        <h1> OpenSSFベストプラクティスバッジプログラム</h1>
        <p>こんにちは、</p>
        <p>
        GitHubアカウントに接続してくださりありがとうございます。OpenSSFベストプラクティス バッジ プログラムにようこそ！
        </p>
        <p>
        この操作を開始していない場合は、[設定]＆gt; [セキュリティ]の下にあるGitHubのセキュリティ ログを確認してください。
        </p>
      before_text: |-
        こんにちは、
        GitHubアカウントに接続してくださりありがとうございます
        OpenSSFベストプラクティス バッジ プログラムへようこそ！
        この操作を開始していない場合は、GitHubの設定>セキュリティの下にあるセキュリティ ログをチェックしてください。
      subject: バッジ プログラムへようこそ
    user_update:
      before_text: あなたのアカウントのユーザー データの一部が更新されました。
      username_changed: ユーザー名が変更されました。
      email_changed: メールアドレスが変更されました。
      password_changed: パスワードが変更されました
      locale_changed: 場所が変更されました。
      current_state: 現在の状態については、以下を参照してください。
      after_text: 問題があればお知らせください。
      subject: ユーザー データが編集されました
    password_reset:
      before_html: |-
        <h1>パスワード リセット</h1>
        <p>パスワードをリセットするには、以下のリンクをクリックしてください。</p>
      before_text: パスワードをリセットするには、以下のリンクをクリックしてください。
      after_html: |-
        <p>このリンクの有効期限は2時間です。</p>
        <p>
        パスワードの再設定を要求していない場合は、
        このメールを無視してください
        あなたのパスワードはそのままです。
        </p>
      after_text: |-
        このリンクの有効期限は2時間です。
        パスワードの再設定を要求していない場合は、
        このメールを無視してください
        あなたのパスワードはそのままです。
      subject: パスワードのリセット
      reset_password: パスワードを再設定します
  criteria:
    '0':
      description_good:
        description: プロジェクトのウェブサイトは、ソフトウェアが何をするのか（何の問題を解決するのか）を簡潔に記述しなければなりません。
        details: これは、潜在的なユーザーが理解できる言語でなければなりません（例えば、それは最小限の専門用語を使用します）。
        met_placeholder: "（省略可能）簡潔な説明はどこですか？ URLを提供することを検討してください。"
      interact:
        description: >-
          プロジェクトのウェブサイトは、取得方法、フィードバックの提供方法（バグ報告や拡張機能）、ソフトウェアへの貢献方法に関する情報を提供しなければなりません。
        met_placeholder: "（オプション）この情報はどこにありますか？ URLを提供することを検討してください。"
      contribution:
        description: 貢献する方法に関する情報は、貢献プロセス（たとえばプル リクエストが使用されか、など）を説明する必要があります。
        details: >-
          別段の記載がない限り、<a href="https://guides.github.com/activities/contributing-to-open-source/">GitHub上のプロジェクトは、（GitHubが提供する）課題管理とプルリクエストを使用することを想定します</a>。この情報は不足しているかもしれません。すなわち、プロジェクトがプルリクエストと課題追跡ツールを使うことか、メーリングリストへの投稿を言及している。（どちら？）
        met_placeholder: "（URLが必要です）プロセスとは何ですか？どのURLがそれを説明していますか？"
      contribution_requirements:
        description: 貢献する方法に関する情報は、貢献を受け入れるための要件（たとえば、必要なコーディング標準への参照）を含むべきです。
        unmet_placeholder: この情報が必要ない位に、要件が明確であるのはなぜですか？
      floss_license:
        description: プロジェクトによって作成されたソフトウェアは、FLOSSとしてリリースされなければなりません。
        details: >-
          FLOSSは、<a href="https://opensource.org/osd-annotated">オープンソース定義</a>または<a
          href="https://www.gnu.org/philosophy/free-sw.en.html">フリーソフトウェア定義</a>を満たす方法でリリースされたソフトウェアです。そのようなライセンスの例としては、<a
          href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>、<a
          href="https://opensource.org/licenses/MIT">MIT</a>、<a
          href="https://opensource.org/licenses/BSD-2-Clause">2項型BSD</a>、<a
          href="https://opensource.org/licenses/BSD-3-Clause">
          3項型BSD</a>、<a href="https://opensource.org/licenses/Apache-2.0">
          Apache 2.0 </a>、<a href="https://opensource.org/licenses/lgpl-license">Less
          GNU General Public License（LGPL）</a>、および<a href="https://opensource.org/licenses/gpl-license">
          GNU General Public License（GPL）</a>を参照してください。私たちの目的のためには、これはライセンスが以下のものでなければならないことを意味します：<ul>
          <li> <a href="https://opensource.org/licenses">オープンソース・イニシアチブ（OSI）によって承認されたライセンス</a>、または</li>
          <li> <a href="https://www.gnu.org/licenses/license-list.html">フリーソフトウェア財団（FSF）の承認を得たフリー
          ライセンス</a>、または</li> <li> <a href="https://www.debian.org/legal/licenses/">
          Debianメインに受け入れられるフリー ライセンス</a>、または</li> <li> <a href="https://fedoraproject.org/wiki/Licensing:Main?rd=Licensing">Fedoraによって「良い」ライセンス</a>.</li>
          </ul> ソフトウェアは他の方法でライセンスされているかもしれません（たとえば、「GPLv2またはプロプライエタリ」は許容されます）。
      floss_license_osi:
        description: >-
          プロジェクトによって作成されたソフトウェアに必要なライセンスは、<a href="https://opensource.org/licenses">オープンソース・イニシアチブ（OSI）によって承認されている</a>ことが推奨されています。
        details: OSIは、厳格な承認プロセスを使用して、どのライセンスがOSSであるかを判断します。
      license_location:
        description: プロジェクトは、結果のライセンスをソースリポジトリの標準的な場所に投稿しなければなりません。
        details: >-
          たとえば、LICENSEまたはCOPYINGという名前の最上位ファイルです。ライセンスファイル名の後に
          ".txt" や ".md" などの拡張子を付けることができます。別の規則は、ライセンスファイルを含むLICENSESという名前のディレクトリを持つことです。これらのファイルは通常、<a
          href="https://reuse.software/spec/"> REUSE仕様</a>で説明されているように、SPDXライセンス識別子とそれに続く適切なファイル拡張子として名前が付けられます。この基準は、ソースリポジトリの要件にすぎないことに注意してください。ソースコード（実行可能ファイル、パッケージ、コンテナなど）から何かを生成するときに、ライセンスファイルを含める必要はありません。たとえば、Comprehensive
          R Archive Network（CRAN）のRパッケージを生成するときは、標準のCRANプラクティスに従います。ライセンスが標準ライセンスの場合は、標準の短いライセンス仕様を使用して（テキストのコピーをさらにインストールしないようにするため）、リストします。
          .Rbuildignoreなどの除外ファイル内のLICENSEファイル。同様に、Debianパッケージを作成する場合、著作権ファイルに
          /usr/share/common-licenses のライセンス テキストへのリンクを配置し、作成したパッケージからライセンス
          ファイルを除外できます（たとえば、dh_auto_installを呼び出した後にファイルを削除します ）。可能な場合は、生成された形式で機械可読ライセンス情報を含めることをお勧めします。
      documentation_basics:
        description: >-
          プロジェクトは、プロジェクトによって作成されたソフトウェアに関する基本的なドキュメンテーションを提供しなければなりません。
        details: >-
          このドキュメントは、インストール方法、起動方法、使用方法（可能であれば例示したチュートリアル）、および、そのソフトウェアの適切なトピックであれば安全に使用する方法（たとえば何をするべきで、何をすべきでないか）を記述し、メディア（たとえば、テキストやビデオなど）に収められている必要があります。セキュリティの文書は必ずしも長文である必要はありません。プロジェクトは、ドキュメンテーションとしてプロジェクト以外の素材へのハイパーテキストリンクを使用してもよいです。プロジェクトがソフトウェアを作成しない場合は、「該当なし」（N
          / A）を選択します。
        met_placeholder: "（オプション）どのURLがドキュメントの開始点を示していますか？"
      documentation_interface:
        description: >-
          プロジェクトは、プロジェクトによって作成されたソフトウェアの外部インタフェース（入力と出力の両方）を記述する参照ドキュメントを提供しなければなりません。
        details: >-
          外部インターフェイスのドキュメントは、エンドユーザーまたは開発者に、その使用方法を説明します。ドキュメントには、ソフトウェアにアプリケーション
          プログラム インターフェイス（API）が含まれている場合、アプリケーション プログラム インターフェイスが含まれます。ライブラリの場合、呼び出すことができる主要なクラス/型とメソッド/関数を文書化します。ウェブ
          アプリケーションの場合、URLインタフェース（多くの場合、RESTインタフェース）を定義します。コマンドラインインターフェイスの場合は、サポートするパラメータとオプションを文書化します。多くの場合、ドキュメントのほとんどを自動生成すると、ソフトウェアが変更されたときにドキュメントがソフトウェアと同期したままなので、最も良い方法ですが、これは必須ではありません。プロジェクトは、ドキュメンテーションとしてプロジェクト以外の素材へのハイパーテキストリンクを使用してもよいです。ドキュメンテーションは自動的に生成されるかもしれません（実際的に、しばしばこれを行う最良の方法です）。
          RESTインタフェースのドキュメントは、Swagger / OpenAPIを使用して生成することができます。コード
          インタフェースのドキュメントは、<a href="http://usejsdoc.org/"> JSDoc
          </a>（JavaScript）、<a href="https://esdoc.org/"> ESDoc
          </a>（JavaScript）、pydoc（Python）、<a href="https://cran.r-project.org/web/packages/devtools/index.html">devtools</a>
          (R)、<a href="https://cran.r-project.org/web/packages/pkgdown/index.html">pkgdown</a>
          (R)、およびDoxygen（多数）のいずれかです。実装コードにコメントがあるだけでは、この基準を満たすには不十分です。すべてのソースコードを読むことなく情報を見るための簡単な方法が必要です。プロジェクトがソフトウェアを作成しない場合は、「該当なし」（N/A）を選択します。
      sites_https:
        description: >-
          プロジェクトサイト（ウェブサイト、リポジトリ、およびダウンロードURL）は、TLSを使用したHTTPSをサポートしなければなりません。
        details: >-
          これには、プロジェクトのホームページのURLとバージョン管理リポジトリのURLが「http：」ではなく「https：」で始まる必要があります。<a
          href="https://letsencrypt.org/">Let's Encrypt</a>からフリーの証明書を入手できます。プロジェクトは、（例えば）<a
          href="https://help.github.com/articles/securing-your-github-pages-site-with-https/">
          GitHubページ</a>、<a href="https://about.gitlab.com/2016/12/24/were-bringing-gitlab-pages-to-community-edition/">
          GitLabページ</a>、または<a href="https://sourceforge.net/blog/introducing-https-for-project-websites/">SourceForgeプロジェクトページ</a>を使ってこの基準を実装してもよいです。HTTPをサポートしている場合は、HTTPトラフィックをHTTPSにリダイレクトすることを強くお勧めします。
      discussion:
        description: >-
          プロジェクトは、議論（提案された変更や問題を含む）のための1つ以上の検索可能なメカニズムを持たなければならず、メッセージやトピックがURLでアドレス指定され、新しい人々がディスカッションのいくつかに参加できるようにしなければならず、クライアント側でプロプライエタリなソフトウェアのインストールを必要としないようにします。
        details: >-
          受け入れ可能なメカニズムの例には、アーカイブされたメーリングリスト、GitHubのイシューとプルリクエストの議論、Bugzilla、Mantis、Tracなどがあります。非同期ディスカッション
          メカニズム（IRCなど）は、これらの基準を満たしていれば許容されます。 URLアドレス可能なアーカイブ機構があることを確認してください。独自のJavaScriptは、推奨されませんが、許可されています。
      english:
        description: プロジェクトは英語で文書を提供し、英語でコードに関するバグ報告とコメントを受け入れることができるべきです。
        details: >-
          現在、英語はコンピュータ技術の<a href="https://en.wikipedia.org/wiki/Lingua_franca">リンガ
          フランカ</a>です。英語をサポートすることで、世界中のさまざまな潜在的な開発者とレビュアーの数を増やします。コア開発者の主要言語が英語でなくても、プロジェクトはこの基準を満たすことができます。
      repo_public:
        description: プロジェクトには、公開され、URLを持つ、バージョン管理のソース リポジトリがなければなりません。
        details: >-
          URLはプロジェクトのURLと同じであってもよいです。プロジェクトは、変更が公開されていない間に（例えば、公開前に脆弱性を修正するため）、特定のケースでプライベート（非公開）ブランチを使用することができます。
      repo_track:
        description: >-
          プロジェクトのソース リポジトリは、どのような変更が行われたのか、誰が変更を行ったのか、いつ変更が行われたのかを追跡しなければなりません。
      repo_interim:
        description: >-
          共同レビューを可能にするために、プロジェクトのソースリポジトリには、リリース間のレビューのための中間バージョンが含まれなければなりません。最終リリースのみを含めることはできません。
        details: >-
          プロジェクトは、公開ソース リポジトリから特定の暫定版を省略することを選択することができます。（たとえば、特定の非公開のセキュリティ脆弱性を修正するものは、公開されないか、または、合法的に投稿できないか、最終リリースに入らないです）
      repo_distributed:
        description: プロジェクトのソース リポジトリに共通の分散バージョン管理ソフトウェア（gitなど）を使用することを推奨します。
        details: >-
          Gitが特別に必要とされているわけでなく、プロジェクトでは、集中型バージョン管理ソフトウェア（例：subversion）を正当とする証拠を持って使用できます。
      version_unique:
        description: プロジェクトの結果には、ユーザーが使用することを意図されたリリースごとに固有のバージョン識別子が必要です。
        details: >-
          これはコミットID（git commit idやmercurial changeset idなど）やバージョン番号（YYYYMMDDのようなセマンティックバージョニングや日付ベースのスキームを使用するバージョン番号を含む）など、さまざまな方法で対応できます。
      version_semver:
        description: >-
          リリースには、<a href="https://semver.org">Semantic Versioning
          (SemVer)</a>または<a href="https://calver.org/" >Calendar
          Versioning (CalVer)</a>のバージョン番号形式を使用することが推奨されます。CalVerを使用する場合は、マイクロレベル値を含めることが推奨されます。
        details: >-
          プロジェクトは一般的に、エコシステムで使用されている通常のフォーマットなど、ユーザーが期待しているフォーマットを優先するべきです。多くのエコシステムではSemVerが好まれており、一般的にSemVerはアプリケーションプログラマインターフェース（API）やソフトウェア開発キット（SDK）に好まれています。CalVerは、規模が大きく、独自に開発した依存関係が異常に多いプロジェクトや、スコープが常に変化するプロジェクト、時間的な制約があるプロジェクトで使用される傾向があります。CalVerを使用する際には、マイクロレベルの値を含めることが推奨されます。マイクロレベルを含めることで、必要になった場合にはいつでも同時にメンテナンスされるブランチをサポートできるからです。git
          commit ID や mercurial changeset ID など、バージョンを一意に識別できるものであれば、他のバージョン番号形式をバージョン番号として使用することができます。しかし、(git
          commit ID のような)いくつかの代替形式は、リリースの識別子として問題を引き起こす可能性があります。すべての受信者が最新バージョンを実行しているだけの場合
          （たとえば、継続的な配信を介して常に更新されている単一のWebサイトまたはインターネットサービスのコード）には、バージョン
          ID の形式はソフトウェアのリリースを識別する上で重要ではないかもしれません。
      version_tags:
        description: >-
          プロジェクトがバージョン管理システム内の各リリースを特定することが推奨されています。たとえば、gitを使用しているユーザーがgitタグを使用して各リリースを特定することが推奨されています。
      release_notes:
        description: >-
          プロジェクトは、各リリースにおいて、ユーザーがアップグレードすべきかどうか、また、アップグレードの影響を判断できるよう、そのリリースの主要な変更の要約を説明したリリースノートを提供しなければなりません（MUST）。リリースノートは、バージョン管理ログの生の出力であってはなりません（例えば、
          "git log"コマンドの結果はリリースノートではない）。プロジェクトの成果物が複数の場所で再利用されることを意図していないプロジェクト（単独のウェブサイトやサービスのためのソフトウェアなど）で、かつ、継続的・断続的な配布を行う場合は、「該当なし」を選択することができます。
        details: >-
          リリースノートは様々な方法で実装できます（MAY）。多くのプロジェクトは、 "NEWS"、 "CHANGELOG"、または
          "ChangeLog"という名前のファイルでそれらを提供し、 ".txt"、 ".md"、 ".html"などの拡張子を付けることもあります。歴史的には、
          "change log"という言葉は<em>すべての</em>変更のログを意味していましたが、本基準を満たすために必要なものは、人間が読める要約です。リリースノートは代わりに、<a
          href="https://github.com/blog/1547-release-your-software">
          GitHubリリースのワークフロー</a>などのバージョン管理システムのメカニズムによって提供してもよい（MAY）。
      release_notes_vulns:
        description: >-
          リリースノートでは、このリリースで修正された、リリースの作成時にすでにCVE割り当てなどがあった、公に知られているランタイムの脆弱性をすべて特定する必要があります。
          ユーザーが通常、ソフトウェアを実際に更新できない場合（たとえば、カーネルの更新によくあることです）、この基準は該当なし（N/A）としてマークされる場合があります。
          この基準はプロジェクトの結果にのみ適用され、依存関係には適用されません。 リリースノートがない場合、または公に知られている脆弱性がない場合は、[N/A]を選択します。
        details: >-
          この基準は、特定の更新によって一般に知られている脆弱性が修正されるかどうかをユーザーが判断するのに役立ち、ユーザーが情報に基づいて更新について決定できるようにします。ユーザーが通常、コンピューター上でソフトウェア自体を実際に更新することはできず、代わりに1つ以上の仲介者に依存して更新を実行する必要がある場合（カーネルお​​よびカーネルと絡み合っている下位レベルのソフトウェアの場合によくあることです）、この追加情報はそれらのユーザーには役立たないため、プロジェクトは「該当なし」（N/A）を選択する場合があります。同様に、すべての受信者が最新バージョンのみを実行している場合（継続的デリバリーによって絶えず更新される単一のWebサイトまたはインターネットサービスのコードなど）、プロジェクトはN/Aを選択できます。この基準はプロジェクトの結果にのみ適用され、依存関係には適用されません。プロジェクトのすべての推移的な依存関係の脆弱性を一覧表示することは、依存関係が増加および変化するにつれて扱いにくくなるため、不要です。依存関係を調べて追跡するツールがよりスケーラブルな方法でこれを実行できます。
      report_process:
        description: >-
          プロジェクトは、ユーザーが不具合報告を送信するプロセスを提供しなければなりません（たとえば、課題トラッカーやメーリングリストを使用します）。
      report_tracker:
        description: プロジェクトは、個々の課題を追跡するための課題トラッカーを使用するべきです。
        unmet_placeholder: 課題トラッカーがないのはなぜですか？
      report_responses:
        description: >-
          このプロジェクトは、過去2〜12か月間に提出された多数のバグ報告の受領を認めなければなりません。応答に修正を含める必要はありません。
      enhancement_responses:
        description: プロジェクトは、直近2〜12ヶ月（2ヶ月を含む）に増強要求の多数（> 50％）に対応すべきです。
        details: >-
          応答は、「いいえ」や、そのメリットについての議論であってもよいです。目標は、単にプロジェクトがまだ生きていることを示している、いくつかの要求に対する応答があることです。この基準のために、プロジェクトは偽のリクエスト（スパマーや自動システムなど）をカウントする必要はありません。プロジェクトで機能強化が行われていない場合は、「満足されない」（unmet）を選択し、この状況をユーザーに明確にするURLを含めてください。プロジェクトが強化要求の数によって圧倒される傾向がある場合は、「満足されない」（unmet）を選択して説明してください。
      report_archive:
        description: プロジェクトは、後で検索するために、レポートとレスポンスのアーカイブを公開する必要があります。
      vulnerability_report_process:
        description: プロジェクトは、脆弱性を報告するプロセスをプロジェクト サイトに公開しなければなりません。
        details: >-
          たとえば、https：// PROJECTSITE / securityの明示的に指定されたメール アドレスで、これはしばしばsecurity@example.orgの形式です。これはバグ報告プロセスと同じかもしれません。脆弱性レポートは常に公開される可能性がありますが、多くのプロジェクトでは、プライベート脆弱性を報告するメカニズムがあります。
      vulnerability_report_private:
        description: >-
          プライベート脆弱性報告がサポートされている場合、プロジェクトは、プライベートに保持された方法で情報を送信する方法を含んでいなくてはなりません。
        details: >-
          例としては、HTTPS（TLS）を使用してWeb上に提出されたプライベート不具合報告や、OpenPGPを使用して暗号化された電子メールがあります。脆弱性報告が常に公開されている場合（プライベート脆弱性報告は存在しないため）、「該当なし」（N
          / A）を選択します。
      vulnerability_report_response:
        description: 過去6ヶ月間に受け取った脆弱性報告に対するプロジェクトの初期応答時間は、14日以下でなければなりません。
        details: 過去6か月間に脆弱性が報告されていない場合は、「該当なし」（N/A）を選択します。
      build:
        description: >-
          プロジェクトによって作成されたソフトウェアを利用するためにビルドが必要な場合、プロジェクトは、ソース コードからソフトウェアを自動的にリビルドできる作業ビルド
          システムを提供しなければなりません。
        details: >-
          ビルドシステムは、ソフトウェアをリビルドするのに必要なアクション（およびその順序）を決定し、それらのステップを実行します。たとえば、ビルドシステムは、ソースコードをコンパイルするためにコンパイラを呼び出すことができます。実行可能ファイルがソースコードから生成される場合、ビルドシステムは、プロジェクトのソースコードを変更でき、その変更を含む更新された実行ファイルを生成できなければなりません。プロジェクトによって生成されたソフトウェアが外部ライブラリに依存する場合、ビルドシステムはそれらの外部ライブラリをビルドする必要は<em>ありません</em>。ソースコードが変更されても、ソフトウェアを使用するためにビルドする必要がない場合、「該当なし」（N/A）を選択します。
      build_common_tools:
        description: ソフトウエアをビルドするために、一般的なツールを使用することをお勧めします。
        details: >-
          たとえば、Maven、Ant、cmake、autotools、make、rake (Ruby)、 <a
          href="https://cran.r-project.org/web/packages/devtools/index.html">devtools</a>
          （R）などです。
      build_floss_tools:
        description: プロジェクトは、FLOSSツールだけを使用してビルドができるようにするべきです。
      test:
        description: >-
          プロジェクトは、FLOSSとして公開されている自動テストスイートを少なくとも1つ使用する必要があります（このテストスイートは、別個のFLOSSプロジェクトとして維持される場合があります）。
          プロジェクトは、テストスイートの実行方法を明確に示すか文書化する必要があります（たとえば、継続的インテグレーション（CI）スクリプトを介して、またはBUILD.md、README.md、CONTRIBUTING.mdなどのファイルの文書を介して）。
        details: >-
          プロジェクトでは、複数の自動化されたテストスイートを使用することができます（たとえば、迅速に実行するもの、より完全であるが特別な装置が必要なもの）。<a
          href="https://www.seleniumhq.org/">Selenium</a> (ウェブブラウザの自動化)、<a
          href="https://junit.org">Junit</a> (JVM, Java)、<a href="https://CRAN.R-project.org/package=RUnit">RUnit</a>
          (R)、<a href="https://cran.r-project.org/web/packages/testthat/index.html">testthat</a>
          (R) など、多くのテストフレームワークやテスト支援システムが利用可能です。
      test_invocation:
        description: テスト スイートは、その言語の標準的な方法で呼び出すことができるべきです。
        details: たとえば、「make check」、「mvn test」、「rake test」（Ruby）などです。
      test_most:
        description: >-
          テスト スイートは、コードブランチ、入力フィールド、および機能のほとんど（または理想的にはすべて）をカバーすることが推奨されています。
      test_continuous_integration:
        description: >-
          プロジェクトは、継続的インテグレーション（新しいコードまたは変更されたコードが頻繁に中央コードリポジトリに統合され、その結果に対して自動テストが実行される）を実装することを推奨されています。
      test_policy:
        description: >-
          プロジェクトは、プロジェクトで作成されたソフトウェアに主要な新機能が追加されたときに、その機能のテストを自動化されたテスト
          スイートに追加する必要があるという一般的な方針（正式でも、正式でなくても構いません）を持っていなければなりません。
        details: >-
          開発者はテストを自動テスト スイートに追加して、新しい機能を追加する必要があるというポリシーが、口頭でも（文書化されていなくても）、存在する限り、「満たしている」を選択してください。
      tests_are_added:
        description: >-
          プロジェクトによって作成されたソフトウェアの最新の大きな変更で、テストを追加するための<a href="#test_policy">
          test_policy </a>が守られているという証拠がプロジェクトに存在しなければなりません。
        details: >-
          主要な機能は、通常、リリースノートに記載されます。完璧は必要ないですが、プロジェクトによって生成されたソフトウェアに新しい主要機能が追加されたときに、自動テスト
          スイートに実際にテストが追加されているという証拠となります。
      tests_documented_added:
        description: >-
          テストを追加するこのポリシー（<a href="#test_policy">test_policy</a>を参照）を変更提案に関する手順で<em>文書化</em>することを推奨します。
        details: しかし、実際にテストが追加されている限り、非公式の規則でも許容されます。
      warnings:
        description: |-
          プロジェクトは、選択した言語でこの基準を実装することができる少なくとも1つのFLOSSツールがあれば、1つまたは複数のコンパイラ警告フラグ、「安全」言語モードを使用可能にするか、分離
          「リンター」ツールを使用してコード品質エラーまたは共通の単純なミスを検索しなければなりません。
        details: >-
          コンパイラ警告フラグの例には、gcc / clang "-Wall"があります。 「安全」言語モードの例には、JavaScript「use
          strict」とperl5の「use warnings」があります。分離「リンター」ツールは、ソースコードを調べてコード品質のエラーや一般的な単純なミスを探すツールです。これらは、通常、ソースコードまたはビルド命令内で有効になります。
      warnings_fixed:
        description: プロジェクトは警告を出さなければならない。
        details: >-
          これらは、<a href="#warnings">警告</a>基準の実装によって識別される警告です。プロジェクトは、警告を修正するか、ソースコード内で警告を誤検出としてマークするべきです。理想的には警告がないことがいいですが、プロジェクトはある程度の警告（通常は100行あたり1警告未満、または全体で10警告未満）を受け入れることができます。
      warnings_strict:
        description: プロジェクトによって作成されたソフトウェアにある警告に、実際的な場合には、最大限に厳格になることを推奨されています。
        details: >-
          一部の警告は、あるプロジェクトでは効果的に有効にすることはできません。必要なのは、プロジェクトが可能な限り警告フラグを有効にするように努力しており、エラーが早期に検出されるという証拠です。
      know_secure_design:
        description: >-
          プロジェクトには、安全なソフトウェアを設計する方法を知っている少なくとも1人の主要な開発者が必要です。
          （正確な要件については、「詳細」を参照してください。）
        details: >-
          これには、<a href="https://web.mit.edu/Saltzer/www/publications/protection/">Saltzer
          and Schroeder </a>の8つの原則を含む以下の設計原則を理解する必要があります。<ul>
          <li>メカニズムの経済性（たとえば、スイーピング シンプリフィケーションを採用して、メカニズムを実際的に単純化し小さくする）<li>フェイルセーフのデフォルト（アクセスの決定はデフォルトで拒否されるべきであり、プロジェクトのインストールはデフォルトで安全でなければならない）<li>完全なメディエーション（制限されたすべてのアクセスは権限がチェックされ、バイパスされない）<li>オープンな設計（セキュリティメカニズムは攻撃者の設計に対する無知に依存するべきではなく、
          簡単に保護ができて変更ができる鍵やパスワードのような情報に依存すべきです。<li>特権の分離（理想的には、重要なオブジェクトへのアクセスは複数の条件に依存すべきで、1つの保護システムを破ることで完全なアクセスが可能にならないようにします。たとえば、パスワードとハードウェア
          トークンを必要とする多因子認証は単因子認証より強いです。<li>最低限の権限（プロセスは最低限の権限で動作する必要がある）<li>最低限の共通メカニズム（設計は、複数のユーザに共通のメカニズムや全てのユーザーに依存するメカニズムを最小限に抑えるべきです。）
          <li>心理学的受容性（ヒューマンインタフェースは、使いやすく設計されていなければならない - 「驚きが最小限になる」という設計が助けになる）<li>限られた攻撃面（攻撃面
          - 攻撃者がデータを入力または抽出しようとする部分 - を制限する必要があります）<li>ホワイト リストで入力を検証します（入力は通常、この検証はブラックリスト（既知の不良値をリストする）ではなく、ホワイトリスト（既知の値のみを受け入れる）を使用する必要があります。
          </ul>プロジェクトの「主要な開発者」とは、プロジェクトのコードベースに精通していて、容易に変更を加えることができ、プロジェクトの他のほとんどの参加者によって認められている人です。主要な開発者は、通常、過去1年間に（コード、文書、または質問に回答して）多数の貢献を行います。ある開発者が、プロジェクトを開始している（3年以上プロジェクトから離れていない）、プライベート脆弱性報告チャネル（存在する場合）に関する情報を受け取る、プロジェクトを代表してコミットを受け入れる、最終リリースする、などを行う時主要な開発者とみなすことができます。開発者が1人だけの場合、その人物が主要開発者です。より安全なソフトウェアを開発し、設計について議論する方法を理解するのに役立つ多くの本やコースが利用可能です。
          たとえば、<a href="https://openssf.org/edx-courses/"> Secure
          Software Development Fundamentals </a>コースは、3つのコースの無料セットです。
          より安全なソフトウェアを開発する方法を説明しています。
      know_common_errors:
        description: >-
          プロジェクトの主要開発者の少なくとも1人は、この種のソフトウェアの脆弱性につながる一般的な種類のエラーを知っていなければならず、それぞれを対策または緩和する少なくとも1つの方法を知っていなければなりません。
        details: >-
          例（ソフトウェアの種類によって異なります）には、SQLインジェクション、OSインジェクション、従来のバッファオーバーフロー、クロスサイトスクリプティング、認証の欠落、承認の欠落などがあります。一般的に使用されるリストについては、
          <a href="https://cwe.mitre.org/top25/">CWE/SANSトップ25</a>または<a
          href="https://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project">OWASPトップ10</a>を参照してください。より安全なソフトウェアを開発する方法を理解し、脆弱性につながる一般的な実装エラーについて説明するのに役立つ多くの書籍やコースが用意されています。たとえば、
          <a href="https://openssf.org/edx-courses/">Secure Software
          Development Fundamentals</a>コースは、より安全なソフトウェアを開発する方法を説明する3つのコースの無料セットです（受講は無料です。追加料金を払うと、学習したことを証明する証明書を入手できます）。
      crypto_published:
        description: >-
          プロジェクトによって作成されたソフトウェアは、デフォルトで、一般に公開され、専門家によってレビューされている暗号プロトコルとアルゴリズムを使用しなければなりません。（暗号プロトコルとアルゴリズムが使用される場合）
        details: ソフトウェアによっては暗号機能を直接使用する必要がないため、これらの暗号基準は常に適用されるわけではありません。
      crypto_call:
        description: >-
          プロジェクトによって作成されたソフトウェアがアプリケーションまたはライブラリであり、主な目的が暗号の実装でない場合、暗号機能を実装するために特別に設計されたソフトウェアを呼び出すだけにするべきです。自分用に（暗号機能を）再実装するべきではありません。
      crypto_floss:
        description: >-
          暗号に依存するプロジェクトによって作成されるソフトウェアのすべての機能は、FLOSSを使用して実装可能でなければなりません。
        details: >-
          <a href="https://opensource.org/osr">オープン ソース イニシアチブによるオープン
          スタンダード要件</a>を参照して下さい。
      crypto_keylength:
        description: >-
          プロジェクトによって作成されたソフトウェア内にあるセキュリティ メカニズムは、少なくとも、2030年までのNIST最小要件（2012年）を満たすデフォルト鍵長を使用しなければなりません。より小さな鍵長を完全に無効になるおうに、ソフトウェアを構成できなければなりません。
        details: >-
          これらの最小ビット長は、対称鍵112、ファクタリング係数2048、離散対数鍵224、離散対数群2048、楕円曲線224、ハッシュ224（パスワードハッシュはこのビット長でカバーされません。パスワードハッシュに関する詳しい情報は
          <a href="#crypto_password_storage">crypto_password_storage</a>
          基準にあります）です。さまざまな機関が出している推奨鍵長の比較については、<a href="https://www.keylength.com">https://www.keylength.com</a>を参照してください。ソフトウェアは、
          いくつかの構成ではより短い鍵長を許可するかもしれません（これはダウングレード攻撃を許すので、理想的には正しくありません。しかし、短い鍵長は、相互運用性のために時に必要となります）。
      crypto_working:
        description: >-
          プロジェクトによって生成されたソフトウェア内のデフォルトのセキュリティメカニズムは、壊れた暗号化アルゴリズム（MD4、MD5、シングルDES、RC4、Dual_EC_DRBGなど）に依存したり、実装する必要がない限り、コンテキストに不適切な暗号化モードを使用したりしてはなりません。相互運用可能なプロトコル（実装されたプロトコルがネットワークエコシステムによって広くサポートされている標準の最新バージョンであり、そのエコシステムではそのようなアルゴリズムまたはモードの使用が必要であり、そのエコシステムはこれ以上安全な代替手段を提供しません）。これらの壊れたアルゴリズムまたはモードが相互運用可能なプロトコルに必要な場合、ドキュメントには、関連するセキュリティリスクと既知の緩和策を記載する必要があります。
        details: >-
          ECBモードは、 <a href="https://blog.filippo.io/the-ecb-penguin/">ECBペンギン</a>によって示されるように暗号文内の同一のブロックを明らかにするため、ほとんど適切ではありません。また、CTRモードは、認証を実行せず、入力状態が繰り返されると重複を引き起こすため、不適切なことがよくあります。多くの場合、Galois
          / Counter Mode（GCM）やEAXなど、機密性と認証を組み合わせるように設計されたブロック暗号アルゴリズム
          モードを選択するのが最善です。プロジェクトは、互換性のために必要な場合、ユーザーが壊れたメカニズムを有効にすることを許可する場合があります（構成中など）が、ユーザーはそれを実行していることを認識します。
      crypto_weaknesses:
        description: >-
          プロジェクトによって作成されたソフトウェア内のデフォルトのセキュリティ メカニズムは、既知の重大な脆弱性を持つ暗号アルゴリズムやモード（たとえば、SHA-1暗号ハッシュ
          アルゴリズムまたはSSHのCBC モード）に依存するべきではありません。
        details: >-
          SSHのCBCモードに関する懸念事項は、 <a href="https://www.kb.cert.org/vuls/id/958563">CERT:
          SSH CBC 脆弱性</a>にて議論されています。.
      crypto_pfs:
        description: >-
          プロジェクトによって作成されたソフトウェア内のセキュリティ メカニズムは、鍵合意プロトコルのための完全な順方向秘密を実装するべきなので、もし長期鍵が将来侵害された場合でも、長期鍵のセットから導出されるセッション鍵は侵害されません。
      crypto_password_storage:
        description: >-
          プロジェクトによって作成されたソフトウェアが外部ユーザーの認証用のパスワードの保存を引き起こす場合、パスワードは、キーストレッチ（反復）アルゴリズム（Argon2id、Bcrypt、Scrypt、PBKDF2など）を使用して、ユーザーごとのソルトで反復ハッシュとして保存される必要があります。<a
          href="https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html">OWASP
          Password Storage Cheat Sheet</a>も参照してください）。
        details: >-
          この基準は、ソフトウェアがサーバー側Webアプリケーションなどの外部ユーザーのパスワードを使用してユーザーの認証（別名インバウンド認証）を実施している場合にのみ適用されます。ソフトウェアが他のシステムへの認証用のパスワードを保存している場合（別名、アウトバウンド認証、たとえば、ソフトウェアが他のシステムのクライアントを実装している場合）、そのソフトウェアの少なくとも一部がハッシュされていないパスワードにアクセスできる必要があるため、適用されません。
      crypto_random:
        description: >-
          プロジェクトによって作成されたソフトウェア内のセキュリティ メカニズムは、暗号学的にセキュアな乱数発生器を使用して、すべての暗号鍵とナンスを生成しなければなりません。暗号学的にセキュアでない発生器を使用してはいけません。
        details: >-
          暗号学的にセキュアな乱数発生器は、ハードウェアの乱数発生器でも、Hash_DRBG、HMAC_DRBG、
          CTR_DRBG、Yarrow、Fortunaなどのアルゴリズムを使用する暗号学的にセキュアな疑似乱数発生器（CSPRNG）でもよいです。<em>セキュアでない</em>乱数発生器には、Javaのjava.util.RandomとJavaScriptのMath.randomがあります。
      delivery_mitm:
        description: >-
          プロジェクトは、MITM攻撃に対抗する配信メカニズムを使用しなければならない。httpsまたはssh+scpを使用することは許容されます。
        details: >-
          さらに強力な仕組みは、デジタル署名されたパッケージでソフトウェアをリリースすることです。配布システムへの攻撃を緩和するからです。しかし、これは、署名の公開鍵が正当なものであることをユーザーが確信でき、<em>かつ</em>ユーザーが実際に署名をチェックする場合にのみ有効です。
      delivery_unsigned:
        description: >-
          暗号ハッシュ（たとえばSHA1SUM）は、http経由で運んではならず、暗号署名をチェックすることなしに使用してはいけません。
        details: これらのハッシュは、送信中に変更することができます。
      vulnerabilities_fixed_60_days:
        description: 60日を超えて公的に知られている中程度または重大度のパッチが適用されていない脆弱性は存在してはなりません。
        details: >-
          脆弱性は、プロジェクト自体によってパッチされ、リリースされなければなりません（パッチは他の場所で開発される可能性があります）。脆弱性が無料情報と共にCVE（共通脆弱性識別子）を持つとき（例えば、<a
          href="https://nvd.nist.gov/"> National Vulnerability
          Database </a>）、またはプロジェクトに情報が伝えられ、その情報が（おそらくプロジェクトによって）一般に公開されたとき、脆弱性は一般に知られるようになります。<a
          href="https://www.first.org/cvss/">Common Vulnerability
          Scoring System (CVSS)</a>の定性的スコアが中程度以上であれば、脆弱性は中程度以上の深刻度とみなされます。CVSS
          のバージョン 2.0 から 3.1 では、これは CVSS のスコア 4.0 以上に相当します。プロジェクトは、広く利用されている脆弱性データベース（<a
          href="https://nvd.nist.gov">国家脆弱性データベース</a>など）で公開されているCVSSスコアを、そのデータベースで報告されている最新バージョンのCVSSを用いて使用することができます。代わりに、プロジェクトは、脆弱性が公表された時点で計算入力内容が公開されている場合には、脆弱性が公表された時点での<a
          href="https://www.first.org/cvss/">CVSS</a>の最新版を用いて深刻度を計算することができます。<strong>注意</strong>：これは、ユーザーが最大60日間、世界中のすべての攻撃者に対して脆弱なままになる可能性があることを意味します。この基準は、<a
          href="https://security.googleblog.com/2010/07/rebooting-responsible-disclosure-focus.html">責任ある開示の再起動</a>でGoogleが推奨しているものよりも、はるかに簡単に満たすことができることが多いです。なぜなら、Googleはレポートが公開されて<em>いなくても</em>、プロジェクトが通知された時点で60日間の期間が開始されることを推奨しているためです。また、このバッジの基準は、他の基準と同様に、個々のプロジェクトに適用されることにも注意してください。プロジェクトの中には、より大きな包括組織や大規模プロジェクトの一部であり、複数のレイヤーに分かれている場合もあります。また、多くのプロジェクトでは、複雑なサプライチェーンの一部として、他の組織やプロジェクトに成果を提供しています。個々のプロジェクトは、多くの場合、残りの部分をコントロールできませんが、個々のプロジェクトは、脆弱性パッチをタイムリーにリリースするための作業を行うことができます。そのため、私たちは個々のプロジェクトの対応時間に焦点を当てています。
          一旦、個々のプロジェクトからパッチが利用可能になると、他のプロジェクトはそのパッチにどのように対処するかを決定することができます（たとえば、新しいバージョンにアップデートすることもできますし、選別されたソリューションのパッチだけを適用することもできます）。
      vulnerabilities_critical_fixed:
        description: プロジェクトは、すべての重要な脆弱性を、報告された後迅速に修正するべきです。
      no_leaked_credentials:
        description: >-
          公開リポジトリは、パブリックアクセスを制限するための有効なプライベートクレデンシャル（たとえば、有効なパスワードやプライベートキー）を漏らしてはなりません。
        details: >-
          プロジェクトは、パブリック アクセスを制限する意図がない限り、テスト用や重要でないデータベース用の「サンプル」資格情報を漏らす可能性があります。
      static_analysis:
        description: >-
          選択した言語でこの基準を実装するFLOSSツールが少なくとも1つある場合、少なくとも1つの静的コード分析ツール（コンパイラの警告と「安全な」言語モード以外）を、ソフトウェアの主要な製品リリースの提案に、リリース前に適用する必要があります。
        details: >-
          静的コード解析ツールは、ソフトウェアコードを実行せずに特定の入力を用いて（ソースコード、中間コード、または実行可能ファイルとして）調べます。この基準のために、コンパイラの警告と「安全な」言語モードは、静的コード解析ツールとしてカウントされません（これらは通常、速度が重要なため深い解析を行いません）。このような静的コード解析ツールの例には、<a
          href="http://cppcheck.sourceforge.net/">cppcheck</a>
          (C, C++)、<a href="https://clang-analyzer.llvm.org/">clang静的解析</a>
          (C, C++)、<a href="https://spotbugs.github.io/">SpotBugs</a>
          (Java)、<a href="http://findbugs.sourceforge.net/">FindBugs</a>
          (Java) (<a href="https://h3xstream.github.io/find-sec-bugs/">FindSecurityBugs</a>を含む)、<a
          href="https://pmd.github.io/">PMD</a> (Java)、<a href="https://brakemanscanner.org/">Brakeman</a>
          (Ruby on Rails)、<a href="https://cran.r-project.org/web/packages/lintr/index.html">lintr</a>
          (R)、<a href="https://cran.r-project.org/web/packages/goodpractice/index.html">goodpractice</a>
          (R), <a href="https://scan.coverity.com/">Coverity Quality
          Analyzer</a>、<a href="https://www.sonarqube.org/">SonarQube</a>、
          <a href="https://www.codacy.com/">Codacy</a>および <a href="https://saas.hpe.com/en-us/software/sca">HP
          Enterprise Fortify Static Code Analyzer</a>.大きなツールのリストは、<a
          href="https://en.wikipedia.org/wiki/List_of_tools_for_static_code_analysis">静的コード解析のためのWikipediaツール一覧</a>,
          <a href="https://www.owasp.org/index.php/Static_Code_Analysis">静的コード解析に関するOWASP情報</a>、<a
          href="https://samate.nist.gov/index.php/Source_Code_Security_Analyzers.html">
          NISTソースコードセキュリティアナライザのリスト</a>、および<a href="https://www.dwheeler.com/essays/static-analysis-tools.html">ウィーラーの静的解析ツール一覧</a>などがあります。
          使用する実装言語で使用できるFLOSS静的解析ツールがない場合は、「該当なし」（N/A）を選択します。
        na_placeholder: これが満たされないのはなぜですか（たとえば、その言語用のFLOSSツールがないから）？
        met_placeholder: どのような静的解析ツールを使用していますか？
      static_analysis_common_vulnerabilities:
        description: >-
          static_analysis基準に使用される静的解析ツールの少なくとも1つが、分析された言語または環境における共通の脆弱性を探すためのルールまたはアプローチを含むことが、推奨されています。
        details: >-
          一般的な脆弱性を探すために特別に設計された静的解析ツールは、それらを見つける可能性が高いです。つまり、静的ツールを使用すると、通常は問題を見つけるのに役立ちますので、利用を提案しますが、「合格」レベルのバッジには要求しません。
      static_analysis_fixed:
        description: >-
          静的コード解析で発見された中程度および重大度の悪用可能な脆弱性はすべて、それらが確認された後、適時に修正されなくてはなりません。
        details: >-
          <a href="https://www.first.org/cvss/">Common Vulnerability
          Scoring System (CVSS)</a>の基本的な定性的なスコアが中程度以上であれば、脆弱性は中程度以上の深刻度とみなされます。CVSS
          のバージョン 2.0 から 3.1 では、これは CVSS のスコア 4.0 以上に相当します。プロジェクトは、広く利用されている脆弱性データベース（<a
          href="https://nvd.nist.gov">国家脆弱性データベース</a>など）で公開されているCVSSスコアを、そのデータベースで報告されている最新バージョンのCVSSを用いて使用することができます。また、脆弱性が公開された時点で計算入力が公開されている場合には、脆弱性が公開された時点での<a
          href="https://www.first.org/cvss/" >CVSS</a>の最新バージョンを用いて深刻度を計算することもできます。基準
          vulnerabilities_fixed_60_days では、公開後 60 日以内にすべての脆弱性を修正することが要求されていることに注意してください。
      static_analysis_often:
        description: 静的ソースコード解析は、コミットごと、または少なくとも毎日実行することをお勧めします。
      dynamic_analysis:
        description: リリース前に、ソフトウェアの主要な製品リリースに少なくとも1つの動的解析ツールを適用することが示唆されています。
        details: >-
          動的解析ツールは、ソフトウェアを特定の入力で実行して検査します。たとえば、プロジェクトは、ファジングツール（<a
          href="http://lcamtuf.coredump.cx/afl/">アメリカンファジーロップ</a>など）やウェブ
          アプリケーション スキャナ（例：<a href="https://www.owasp.org/index.php/OWASP_Zed_Attack_Proxy_Project">
          OWASP ZAP </a>または<a href="https://w3af.org/"> w3af </a>）です。場合によっては、<a
          href="https://github.com/google/oss-fuzz#introduction">
          OSS-Fuzz </a>プロジェクトがプロジェクトにファズテストを適用する可能性があります。この基準のために、動的分析ツールは、様々な種類の問題を探すために何らかの方法で入力を変更するか<em>または</em>少なくとも80％のブランチ
          カバレッジを持つ自動テスト スイートである必要があります。 <a href="https://en.wikipedia.org/wiki/Dynamic_program_analysis">動的解析に関するWikipediaのページ</a>と<a
          href="https://www.owasp.org/index.php/Fuzzing"> ファジングに関するOWASPページ</a>で、いくつかの動的解析ツールを特定しています。解析ツールは、セキュリティの脆弱性を探すことに重点を置くことができますが、これは必須ではありません。
      dynamic_analysis_unsafe:
        description: >-
          プロジェクトで作成されたソフトウェアにメモリ安全でない言語（CやC ++など）を使用して作成されたソフトウェアが含まれている場合、少なくとも1つの動的ツール（たとえば、ファジーまたはウェブ
          アプリケーション スキャナ）を、バッファの上書きなどのメモリの安全性の問題を検出するメカニズムと一緒にいつも使用します。プロジェクトがメモリ安全でない言語で書かれたソフトウェアを作成しない場合は、「該当なし」（N/A）を選択します。
        details: >-
          メモリの安全性の問題を検出するメカニズムの例としては、<a href="https://github.com/google/sanitizers/wiki/AddressSanitizer">アドレスサニタイザー（ASAN）</a>（GCCおよびLLVMで利用可能）、<a
          href="https://clang.llvm.org/docs/MemorySanitizer.html">
          Memory Sanitizer </a>、および<a href="http://valgrind.org/">
          valgrind </a>が含まれます。他に使用される可能性のあるツールには、<a href="https://clang.llvm.org/docs/ThreadSanitizer.html">スレッドサニタイザ</a>と<a
          href="https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html">定義されていない動作サニタイザ</a>を参照してください。広範なアサーションも機能します。
      dynamic_analysis_enable_assertions:
        description: >-
          プロジェクトでは、多くのアサーションを可能にする少なくとも一部の動的分析（テストやファジングなど）の構成を使用することをお勧めします。多くの場合、これらのアサーションは本番ビルドでは有効にし<i>ない</i>でください。
        details: >-
          この基準は、本番環境でアサーションを有効にすることを示唆するものでは<i>ありません</i>。それは完全にプロジェクトとそのユーザーが決定することです。この基準の焦点は、展開<i>前</i>の動的分析中の障害検出を改善することです。<i>プロダクション</i>環境でのアサーションの有効化は、動的分析（テストなど）中にアサーションを有効にすることとは<i>まったく</i>異なります。場合によっては、プロダクション環境でアサーションを有効にすることは非常に賢明ではありません（特に高整合性コンポーネントの場合）。プロダクション環境でアサーションを有効にすることには多くの議論があります。たとえば、ライブラリは呼び出し元をクラッシュさせてはなりません。ライブラリが存在するとアプリストアによる拒否が発生する可能性があります。また、プロダクション環境でアサーションをアクティブにすると、秘密鍵などの秘密データが公開される可能性があります。多くのLinuxディストリビューションでは<tt>NDEBUG</tt>が定義されていないため、これらのディストリビューションのプロダクション環境ではデフォルトで
          C/C++ <t>assert() が有効になります。これらの環境でのプロダクション環境では、別のアサーションメカニズムを使用するか、
          <tt>NDEBUG</tt>を定義することが重要です。
      dynamic_analysis_fixed:
        description: >-
          動的コード分析で発見されたすべての中程度および重大度の悪用可能な脆弱性は、確認された後、適時に修正されなければなりません。
        details: >-
          動的コード分析を実行しておらず、この方法で脆弱性が見つからない場合は、「該当なし」（N/A）を選択してください。
          <a href="https://www.first.org/cvss/" >Common Vulnerability
          Scoring System (CVSS)</a>の基本的な定性的スコアが中以上の場合、脆弱性は中程度以上の重大度と見なされます。
          CVSSバージョン2.0から3.1では、これは4.0以上のCVSSスコアに相当します。プロジェクトは、広く使用されている脆弱性データベース（
          <a href="https://nvd.nist.gov">National Vulnerability
          Databaseなど</a>）で公開されているCVSSスコアを、そのデータベースで報告されている最新バージョンのCVSSを使用して使用できます。代わりに、脆弱性が公表された後に計算入力が公開された場合、プロジェクトは脆弱性の開示時に最新バージョンの<a
          href="https://www.first.org/cvss/">CVSS</a>を使用して重大度を自ら計算することができます。
      maintained:
        description: プロジェクトはメンテナンスされている必要があります。
        details: >-
          少なくとも、プロジェクトは重大な問題と脆弱性の報告に対応するように努める必要があります。バッジを積極的に追求しているプロジェクトは、おそらくメンテナンスされているでしょう。すべてのプロジェクトや人のリソースには限りがあり、提案された変更をプロジェクトが拒否しなければならないこともあるため、リソースに限りがあることや、提案が拒否されることが、メンテナンスされていないプロジェクトを示すわけではありません。<br><br>プロジェクトが今後メンテナンスされなくなることがわかった場合は、この基準を「不適合（Unmet）」に設定し、適切なメカニズムを使用して、メンテナンスされないことを人々に示す必要があります。たとえば、READMEの最初の見出しに「DEPRECATED」（将来のサポートが保証されないので使用すべきでない）を使用し、ホームページの先頭近くに「DEPRECATED」を追加し、コード
          リポジトリのプロジェクトの説明の先頭に「DEPRECATED」を追加し、そのREADMEおよび/またはホームページに<a
          href="https://unmaintained.tech/">no-maintenance-intendedバッジ</a>を追加し、すべてのパッケージ
          リポジトリでdeprecated（非推奨）としてマークしたり（例： <a href="https://docs.npmjs.com/deprecating-and-undeprecating-packages-or-package-versions">npm
          deprecate</a> ）、コード リポジトリのマーキングシステムを使用してアーカイブします（例：GitHubの<a
          href="https://docs.github.com/en/enterprise-server@2.21/github/creating-cloning-and-archiving-repositories/archiving-a-github-repository">"archive"
          設定</a>、GitLabの<a href="https://docs.gitlab.com/ee/user/project/settings/#archiving-a-project">"archived"
          マーキング</a>、 Gerritの "readonly" ステータス、またはSourceForgeの"abandoned"
          プロジェクト ステータス）。詳細な説明については、<a href="https://medium.com/maintainer-io/how-to-deprecate-a-repository-on-github-8f0ceb9155e">こちら</a>を参照してください。
    '1':
      contribution_requirements:
        description: >-
          貢献する方法に関する情報には、受け入れ可能な貢献の要件（例えば、必要なコーディング標準への言及）が含まれなければなりません。
      dco:
        description: >-
          プロジェクトは、プロジェクト ソフトウェアのそれなりの量を開発しているすべての開発者が、これらの貢献を行うことが法的に認められていると主張すりょうな法的な仕組みを持っていなければなりません。これを行うための最も一般的で簡単に実装されたアプローチは、<a
          href="https://developercertificate.org/">開発者証明書（DCO）</a>を使用することです。ユーザーは、
          DCOのウェブサイトへのプロジェクトのリンクが表示されます。ただし、これはコントリビュータ ライセンス契約（CLA）またはその他の法的な仕組みとして実装することができます。
        details: >-
          DCOは、実装が容易で、ソースコードで追跡され、gitが "commit -s"を使用して "サインオフ"機能を直接サポートするため、推奨されるメカニズムです。最も効果的であるためには、プロジェクト文書が、そのプロジェクトに対して「サインオフ」とは何を意味するのかを説明するのが最善です。
          CLAは、知的著作物が組織またはプロジェクトにライセンスされている条件を定義する法的合意です。コントリビュータ
          アサイン  アグリーメント（CAA）は、知的著作物の権利を他の当事者に移転する法的合意です。プロジェクトはCAAを必ずしも持つ必要はありません。なぜなら、CAAは、特に受領者が営利目的の組織である場合には、潜在的な貢献者が貢献しないリスクを高めます。
          <a href="https://www.apache.org/licenses/"> Apache Software
          Foundation CLA（個々のコントリビュータ ライセンスと法人CLA）</a>は、この種のCLAのリスクを判断するプロジェクトにとって、リスクが便益よりも小さいのCLAの例です。
      governance:
        description: >-
          プロジェクトは、プロジェクト ガバナンス モデル（主要な役割を含む意思決定方法）を明確に定義し、文書化しなければなりません。
        details: >-
          決定を下し、論争を解決するための十分に確立された文書化された方法が必要です。小規模なプロジェクトでは、これは「プロジェクトオーナーとリーダーがすべての最終決定を下す」という単純なものです。慈愛の強い独裁者や正式な能力主義を含む様々な統治モデルが存在します。詳細については、<a
          href="http://oss-watch.ac.uk/resources/governancemodels">統治モデル</a>を参照してください。集中化された（例えば、単一メインテナー）および分散された（例えば、グループ
          メインテナー）アプローチの両方が、プロジェクトにおいて成功のうちに使用されています。統治情報は、プロジェクトフォークを作成する可能性について文書化する必要はありません。なぜなら、これはFLOSSプロジェクトでは常に可能であるからです。
      code_of_conduct:
        description: プロジェクトは、行動規範を採択し、標準的な場所に掲示しなければなりません。
        details: >-
          プロジェクトは、地域社会の礼儀正しさを向上させることと、行動規範を採択することで受け入れられる行動についての期待を設定すること、ができるかもしれません。これにより、問題が発生する前に問題を回避し、プロジェクトをより貢献を促す場所にすることができます。これは、プロジェクトのコミュニティ内や職場内の行動にのみ焦点を当てるべきです。行動規範の例としては、以下のようなものがあります。<a
          href="https://www.kernel.org/doc/html/latest/process/code-of-conduct.html">Linuxカーネル行動規範</a>、<a
          href="https://contributor-covenant.org/">コントリビューター規約行動規範</a>、<a
          href="https://www.debian.org/code_of_conduct">Debian行動規範</a>、<a
          href="https://www.ubuntu.com/about/about-ubuntu/conduct">Ubuntu行動規範</a>、<a
          href="https://getfedora.org/code-of-conduct">Fedora行動規範</a>、<a
          href="https://wiki.gnome.org/action/show/Foundation/CodeOfConduct">GNOME行動規範</a>、<a
          href="https://www.kde.org/code-of-conduct/">KDEコミュニティ行動規範</a>、<a
          href="https://www.python.org/psf/codeofconduct/">Pythonコミュニティ行動規範</a>、<a
          href="https://www.ruby-lang.org/en/conduct/">Rubyコミュニティ行動指針</a>、および<a
          href="https://www.rust-lang.org/en-US/conduct.html">Rust
          行動規範</a>。
      roles_responsibilities:
        description: >-
          プロジェクトは、プロジェクトでの重要な役割と役割が実行しなければならないタスクを含む責任を明確に定義し、公的に文書化しなければなりません。誰がどの役割を持っているかは明確でなければなりませんが、これは同じ方法で文書化されていない可能性があります。
        details: <a href="#governance">統治</a>と役割と責任に関する文章は1か所にあるのが良いでしょう。
      access_continuity:
        description: >-
          いずれかの人が仕事を継続できなくなるまたは死亡した場合、プロジェクトは最小限の中断で継続することができなければなりません。特に、プロジェクトは、課題の作成と終了、提案された変更の受け入れ、およびバージョンのソフトウェアのリリース、1週間内に個人が仕事を継続できくなったことまたは死亡したことの確認、行うことができなければならない。これは、他の誰かがプロジェクトを継続するのに必要な鍵、パスワード、法的権利を持っていることを保証することによって行うことができます。
          FLOSSプロジェクトを実行する個人は、ロックボックスにキーを提供し、必要な法的権利を提供する意志（例えば、DNS名のために）を提供することによって、これを行うことができます。
      bus_factor:
        description: プロジェクトは2以上の "バス ファクタ"を持っているべきです。
        details: >-
          「バス ファクタ」（別名「トラック ファクタ」）は、知見があり有能な人材が離脱して、プロジェクトが停止に至る時に、プロジェクトから突然消失する（「バスに当たった」）プロジェクトメンバーの最小人数です。
          <a href="https://github.com/mtov/truck-factor">トラック
          ファクタ</a>ツールは、GitHub上のプロジェクトに対してこれを見積もることができます。詳細については、Cosentino
          et al。の<a href="https://www.researchgate.net/publication/272824568_assessing_the_bus_factor_of_git_repositories">
          Gitリポジトリのバス ファクタの評価</a>を参照してください。
      documentation_roadmap:
        description: >-
          プロジェクトは、少なくとも翌年に、プロジェクトが何をしたいか、やるつもりはないかを記述した文書化されたロードマップを持っていなければなりません。
        details: >-
          このプロジェクトはロードマップを達成できないかもしれません。それは問題ありません。ロードマップの目的は、潜在的なユーザーや貢献者がプロジェクトの意図された方向を理解するのを助けることです。詳細にする必要はありません。
      documentation_architecture:
        description: >-
          プロジェクトは、プロジェクトによって作成されたソフトウェアのアーキテクチャー（いわゆる高水準設計）の文書を含まなければなりません。プロジェクトでソフトウェアが作成されない場合は、「該当なし」（N/A）を選択します。
        details: >-
          ソフトウェア アーキテクチャは、プログラムの基本的な構造、すなわちプログラムの主な構成要素、それらの間の関係、およびこれらの構成要素および関係の主要な特性を説明します。
      documentation_security:
        description: >-
          プロジェクトは、ユーザーが、プロジェクトによって作成されたソフトウェアからセキュリティの観点から期待できるものと期待できないものを文書化しなければなりません。（セキュリティ要件）
        details: これらは、ソフトウェアが満たすことが意図されているセキュリティ要件です。
      documentation_quick_start:
        description: >-
          プロジェクトでは、新規ユーザーがソフトウェアで何かをすばやく実行できるようにするための「クイックスタート」ガイドを提供する必要があります。
        details: >-
          このアイデアは、ユーザーにソフトウェアを始動させる方法と何かをさせる方法を示すことです。これは潜在的なユーザーが開始するために非常に重要です。
      documentation_current:
        description: >-
          プロジェクトは、現行バージョンのプロジェクト結果（プロジェクトによって作成されたソフトウェアを含む）とドキュメントの整合性を保つために努力しなければならない。
          不一致を招く<em>既知の</em>ドキュメントの欠陥は、修正しなければなりません。ドキュメントが一般的に最新のものですが、古い情報が誤って含まれて、もはや正しくない場合は、それを欠陥として扱い、通常どおりに追跡して修正してください。
        details: >-
          ドキュメントには、ソフトウェアのバージョン間の相違点や変更点、および/またはドキュメントの古いバージョンへのリンクに関する情報が含まれていてもよいです。この基準の意図は、ドキュメントが完璧である必要があることではなく、ドキュメントの一貫性を保つための努力がなされていることです。
      documentation_achievements:
        description: >-
          プロジェクトのリポジトリのフロントページおよび/またはウェブサイトは、このベストプラクティスのバッジを含め、成果が達成されたことを一般に認められてから48時間以内に特定し、ハイパーリンクする必要があります。
        details: >-
          達成とは、いくつかのバッジを含めて、プロジェクトが具体的に満たしている外部基準のセットです。この情報は、プロジェクトのウェブサイトのフロントページにある必要はありません。
          GitHubを使用するプロジェクトは、READMEファイルに追加することで、リポジトリのフロントページに成果を置くことができます。
      accessibility_best_practices:
        description: >-
          プロジェクト（プロジェクト サイトとプロジェクト結果の両方）は、アクセシビリティのベストプラクティスに従い、障害のある人が引き続きプロジェクトに参加し、プロジェクトの結果を合理的な範囲で使用することができるようにするべきです。
        details: |-
          ウェブアプリケーションについては、<a href="https://www.w3.org/TR/WCAG20/">ウェブ コンテンツ アクセシビリティ ガイドライン（WCAG 2.0）</a>とそのサポート ドキュメント<a href="https://www.w3.org/TR/UNDERSTANDING-WCAG20/Overview.html"> WCAG 2.0の理解</a>; <a href="https://www.w3.org/standards/webdesign/accessibility"> W3Cアクセシビリティ情報</a>を参照してください。 GUIアプリケーションの場合は、環境固有のアクセシビリティ ガイドラインの使用を検討して下さい（<a href="https://developer.gnome.org/accessibility-devel-guide/stable/">Gnome</a>、<a href="https://accessibility.kde.org/">KDE</a>、<a href="https://docs.xfce.org/xfce/xfce4-settings/accessibility">XFCE</a>、 <a href="https://developer.android.com/guide/topics/ui/accessibility/"> Android </a>、<a href="https://developer.apple.com/accessi<a href="https://developer.apple.com/accessibility/ios/"><a href="https://developer.apple.com/accessibility/ios/">bility/ios/" > iOS </a>、<a href="https://www.apple.com/accessibility/osx/voiceover/"> Mac </a>、<a href="https://msdn.microsoft.com/en-us/windows/uwp/accessibility/accessibility-overview">Windows </a>）。いくつかのTUIアプリケーション（例えば、「ncurses」プログラム）は、「alpine」の 「force-arrow-cursor」設定のような、よりアクセスしやすくするためにいくつかのことを行うことができます。ほとんどのコマンドライン アプリケーションは、そのままの状態でかなりアクセス可能です。この基準は、例えば、プログラム ライブラリの場合、「該当なし」（N/A）であることが多いです。取り上げるべき行動や考慮すべき課題の例を以下に示します。
          <ul> <li>テキスト以外のコンテンツの代替テキストを提供するkotode,
          人々が必要とする他の形式に変更することができます。大きな印刷物、点字、スピーチ、記号またはより単純な言語などです。（<a href="https://www.w3.org/TR/UNDERSTANDING-WCAG20/text-equiv.html"> WCAG 2.0ガイドライン1.1 </a>）
          <li>アクションを示したり、応答を促したり、または視覚的要素を区別するために、色が唯一の視覚的な伝達手段として使用されるわけではありません。（<a href="https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-without-color.html"> WCAG 2.0ガイドライン1.4.1 </a>）
          <li>大文字、付随的なテキストとロゴタイプを除いて、テキストの視覚的提示とテキストのイメージには、少なくとも4.5：1の比率のコントラストがあります（<a href="https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html"> WCAG 2.0ガイドライン1.4.3 </a>）
          <li>キーボードからすべての機能を利用できるようにする（WCAGガイドライン2.1）
          <li> GUIまたはウェブ ベースのプロジェクトは少なくとも1つターゲットプラットフォーム上のスクリーンリーダーでテストするべきです（例えば、NVDA、Jaws、またはWindows上のWindowEyes; MacとiOSのVoiceOver Linux / BSDのOrca;AndroidのTalkBack）。
          TUIプログラムは、スクリーンリーダーによる冗長な読み取りを防止するために、オーバードローを減らせるかもしれません。
          </ul>
      internationalization:
        description: >-
          プロジェクトによって作成されたソフトウェアは、ターゲット オーディエンスの文化、地域、または言語へのローカリゼーションを容易にするために国際化されるべきです。国際化（i18n）が適用されない場合（たとえば、ソフトウェアがエンドユーザー向けのテキストを生成せず、人間が読めるテキストを扱わない場合）、「該当なし」（N/A）を選択します。
        details: >-
          ローカリゼーションとは、「特定のターゲット市場（ロケール）の言語、文化、およびその他の要件を満たす、製品、アプリケーションまたはドキュメントのコンテンツの適合を指します」。国際化とは、「文化、地域、言語によって異なるターゲットオーディエンスに対してローカライズを容易にする製品、アプリケーション、またはドキュメントコンテンツの設計と開発」のことです。
          （<a href="https://www.w3.org/International/questions/qa-i18n">
          W3Cの「ローカリゼーションと国際化」</a>を参照してください。）ソフトウェアは国際化されるだけでこの基準を満たします。いったんソフトウェアが国際化されると、他の人がローカライゼーションに取り組むことができるので、別の特定の言語のローカリゼーションは必要ありません。
      sites_password_security:
        description: >-
          プロジェクト サイト（ウェブサイト、リポジトリ、およびダウンロードURL）が外部ユーザーの認証用のパスワードを格納する場合、パスワードは、キーストレッチ（反復）アルゴリズム（PBKDF2、Bcrypt、Scrypt、PBKDF2など）を使用してユーザーごとのソルトで反復ハッシュとして保存する必要があります。プロジェクトサイトがこの目的のためにパスワードを保存しない場合は、「該当なし」（N/A）を選択します。
        details: >-
          <a href="https://help.github.com/articles/github-security/">GitHub</a>
          の使用はこの基準を満たしていることに注意してください。この基準は、プロジェクト サイトへの外部ユーザーの認証に使用されるパスワードにのみ適用されます（別名インバウンド認証）。プロジェクト
          サイトが他のサイトにログインしなければならない場合（別名：アウトバウンド認証）、その目的のために別の方法で認証トークンを保存する必要があるかもしれません（ハッシュを保存しても意味がないため）。これは、crypto_password_storage
          の基準を sites_httpsと同様にプロジェクトサイトに適用します。
      maintenance_or_update:
        description: >-
          プロジェクトは、最も頻繁に使用される古いバージョンの製品を維持するか、<em>または</em>新しいバージョンへのアップ
          グレードを提供しなければなりません。アップ グレード方法が困難な場合は、プロジェクトは、アップグレード方法（変更されたインターフェイスや、アップグレードに役立つ詳細な手順など）を記載しなければなりません。
      report_tracker:
        description: プロジェクトは、個々の課題を追跡するための課題トラッカーを使用する必要があります。
      vulnerability_report_credit:
        description: >-
          プロジェクトは、匿名の報告者を除いて、過去12ヶ月間に解決されたすべての脆弱性の報告者に信用していることを伝えなければなりません。過去12ヶ月間に解決された脆弱性がない場合は、「該当なし」（N
          / A）を選択します。
      vulnerability_response_process:
        description: プロジェクトには、脆弱性レポートに対応するための文書化されたプロセスがなければなりません。
        details: >-
          これはvulnerability_report_processに強く関連しており、脆弱性を報告するための文書化された方法が必要です。これは、特定の時間枠内の脆弱性レポートへの応答を必要とする、vulnerability_report_responseにも関連しています。
      coding_standards:
        description: |-
          プロジェクトは、使用する主要な言語のための特定のコーディング
           スタイル ガイドを指定しなければなりませんし、貢献が一般にそれに準拠することを要求しなければなりません。
        details: >-
          ほとんどの場合、これはいくつかの既存のスタイル ガイドを参照し、おそらく差異をリストすることによって行われます。これらのスタイル
          ガイドには、可読性を向上させる方法や、欠陥（脆弱性を含む）の可能性を減らす方法が含まれています。多くのプログラミング言語には、広く使用されているスタイル
          ガイドが1つ以上あります。スタイルガイドの例には、<a href="https://github.com/google/styleguide">
          Googleスタイル ガイド</a>と<a href="https://www.securecoding.cert.org/">
          SEI CERTコーディング標準</a>を参照してください。
      coding_standards_enforced:
        description: >-
          選択した言語において行うことができるFLOSSツールが少なくとも1つあれば、プロジェクトは自動的に選択したコーディングスタイルを適用しなければなりません。
        details: >-
          これは、静的解析ツールを使用して、および/またはコード再フォーマットを介してコードを強制することによって実装することができます。多くの場合、ツールの設定は、プロジェクトのリポジトリに含まれます（プロジェクトによって異なる設定が選択される可能性があるため）。プロジェクトはスタイルの例外を許可するかもしれません（通常はそうなります）。例外が発生した場合は、それらの場所のコードでまれで、文書化されていなければなりませんので、それらの例外が再検討され、ツールが将来自動的にそれらを処理できるようにできます。このようなツールの例には、ESLint（JavaScript）、Rubocop（Ruby）、および
          <a href="https://cran.r-project.org/web/packages/devtools/index.html">devtools
          check</a> (R)があります。
      build_standard_variables:
        description: >-
          ネイティブ バイナリのビルドシステムは、それらに渡される関連するコンパイラおよびリンカ（環境）変数（CC、CFLAGS、CXX、CXXFLAGS、LDFLAGSなど）を受け入れ、コンパイラおよびリンカ呼び出しに渡す必要があります。ビルド
          システムは追加のフラグでそれらを拡張するかもしれません。提供された値を単にそれ自身のものに置き換えてはいけません。ネイティブバイナリが生成されていない場合は、「該当なし」（N/A）を選択します。
        details: >-
          Address Sanitizer（ASAN）などの特別なビルド機能を有効にしたり、ディストリビューション強化のベストプラクティスに準拠したりするのは簡単です（コンパイラフラグを簡単にオンにするなどして）。
      build_preserve_debug:
        description: >-
          ビルドとインストール システムは、関連するフラグ（例えば、 "install -s"が使用されていない）で要求されたデバッグ情報を保存しておくべきです。ビルドやインストール
          システムがない場合（例：一般的なJavaScriptライブラリ）は、「該当なし」（N/A）を選択します。
        details: >-
          すなわち、CFLAGS（C）またはCXXFLAGS（C ++）を設定すると、それらの言語が使用されている場合に、関連デバッグ情報が作成されるべきですし、インストール時には削除するべきではありません。デバッグ情報は、サポートと分析のために必要であり、コンパイルされたバイナリのハードニング機能の存在を測定するのにも役立ちます。
      build_non_recursive:
        description: >-
          プロジェクトによって作成されたソフトウェアのビルド システムは、サブディレクトリに相互依存関係がある場合、再帰的にサブディレクトリをビルドしてはなりません。ビルドやインストール
          システムがない場合（例：一般的なJavaScriptライブラリ）は、「該当なし」（N/A）を選択します。
        details: >-
          プロジェクトのビルド システムの内部依存情報は、正確でなければなりません。そうでないと、プロジェクトへの変更が正しくビルドされないことがあります。ビルドが正しくないと、欠陥（脆弱性を含む）が発生する可能性があります。大規模ビルドシステムでよく見られる間違いは、ソースファイルを含むサブディレクトリの階層で、各サブディレクトリが独立してビルドされるとき、「再帰的ビルド」か「再帰的Make」を使用することです。各サブディレクトリが完全に独立していない限り、依存関係の情報が正しくないため、これらを使用することは間違いです。
      build_repeatable:
        description: >-
          プロジェクトは、ソースファイルから情報を生成するプロセスを繰り返すことができなければならず、ビット単位でまったく同じ結果を得ることができなければなりません。ビルドが発生しない場合（例えば、ソースコードをコンパイルする代わりに直接使用するスクリプト言語）は、「該当なし」（N/A）を選択します。
        details: >-
          GCCとclangのユーザーには、-frandom-seedオプションが有用であるかもしれません。場合によっては、ソート順を強制することで解決できます。
          <a href="https://reproducible-builds.org/">再現可能なビルド</a>サイトで、より多くの提案を見つけることができます。
      installation_common:
        description: >-
          プロジェクトは、プロジェクトで作成されたソフトウェアを一般的に使用されているやり方で簡単にインストールおよびアンインストールする方法を提供する必要があります。
        details: >-
          たとえば、パッケージマネージャー（システムまたは言語レベル）、「make install / uninstall」（DESTDIRをサポート）、標準形式のコンテナー、または標準形式の仮想マシンイメージを使用することが挙げられます。インストールとアンインストールのプロセス（たとえば、パッケージング）は、FLOSSである限り、サードパーティによって実装されてもよいです。
      installation_standard_variables:
        description: >-
          エンドユーザ用のインストール システムは、インストール時にビルドされる生成物が書き込まれる場所を選択するための標準的な規則を守らなければなりません。たとえば、POSIXシステムにファイルをインストールする場合は、DESTDIR環境変数を守らなければなりません。インストール
          システムがない場合や標準的な規約がない場合は、「該当なし」（N / A）を選択します。
      installation_development_quick:
        description: >-
          プロジェクトは、潜在的な開発者がすべてのプロジェクト結果を迅速にインストールし、テストやテスト環境を含む変更を行うために必要な環境を迅速にインストールする方法を提供しなければなりません。これは、一般に使用されている手法で実行する必要があります。
        details: >-
          これは生成されたコンテナおよび/またはインストール スクリプトを使用して実装できます。外部依存部分は、典型的には、external_dependenciesごとにシステムおよび/または言語パッケージマネージャを呼び出すことによってインストールされます。
      external_dependencies:
        description: プロジェクトは、外部依存関係をコンピュータ処理可能な方法でリストしなければなりません。
        details: >-
          通常、これはパッケージ マネージャーやビルドシステムのやり方を使用して行われます。これは<a href="#installation_development_quick">
          installation_development_quick </a>の実装に役立ちます。
      dependency_monitoring:
        description: >-
          プロジェクトは、既知の脆弱性を検出し、悪用可能な脆弱性を修正したり、悪用できない脆弱性として確認するために、外部の依存先（コンビニエンス
          コピーを含む）を監視または定期的にチェックしなければなりません。
        details: >-
          これは、<a href="https://www.owasp.org/index.php/OWASP_Dependency_Check">
          OWASPのDependency-Check </a>、<a href="https://www.sonatype.com/nexus-auditor">
          SinatypeのNexus Auditor </a>、<a href="https://www.synopsys.com/software-integrity/security-testing/software-composition-analysis.html">SynopsysのBlack
          Duck Software Composition Analysis</a>、<a href="https://github.com/rubysec/bundler-audit">
          Bundler-audit （Rubyの場合）</a>などのオリジンアナライザー/依存性検査ツールを使用して行うことができます。パッケージ
          マネージャーには、これを行うためのメカニズムが含まれています。コンポーネントの脆弱性を悪用することはできない場合、分析が難しいが、単に更新または修正する方が簡単なであれば、それは許容できます。
      updateable_reused_components:
        description: |-
          プロジェクトは
          <ol>
          <li>再使用された外部管理コンポーネントの識別と更新を容易にできるようにしている、 <strong>または</strong> </li><li>システムまたはプログラミング言語によって提供される標準コンポーネントを使用している</li>
          </ol>
          のどちらかでなければなりません。そうすれば、再利用されたコンポーネントに脆弱性が見つかった場合に、そのコンポーネントを簡単に更新することができます。
        details: >-
          この基準を満たす典型的な方法は、システムおよびプログラミング言語のパッケージ管理システムを使用することです。多くのFLOSSプログラムは、標準ライブラリーのローカルコピーである
          "コンビニエンス ライブラリー"と一緒に頒布されます（フォークされている可能性があります）。それ自体は、それでいいです。しかし、プログラムがこれらのローカルな（フォークされた）コピーを使用しなければならない場合、
          セキュリティ アップデートとして"標準"ライブラリをアップデートすると、これらの追加のコピーは依然として脆弱のままです。これは、特にクラウド
          ベース システムの問題です。クラウド プロバイダが "標準"ライブラリを更新してもプログラムがそれらを使用しない場合、更新プログラムは実際には役に立ちません。たとえば、<a
          href="https://spot.livejournal.com/312320.html">「Chromium：適切なパッケージとしてFedoraにまだない理由は何ですか？」Tom
          Callaway著</a>を参照してください。
      interfaces_current:
        description: >-
          プロジェクトは、使用するテクノロジ セット（その "テクノロジ スタック"）において、プロジェクトがサポートするユーザの超大多数がFLOSSの代替案を利用可能な（ユーザが代替手段にアクセスしている）場合には、評価の低いまたは時代遅れの機能とAPIの使用を避けるべきです。
      automated_integration_testing:
        description: >-
          少なくとも1つのブランチの共有リポジトリへの各チェックインに対して、自動テスト スイートが適用される必要があります。このテスト
          スイートは、テストの成功または失敗に関するレポートを生成しなければなりません。
        details: >-
          この要件は、test_continuous_integrationのサブセットと見ることができますが、継続的な統合を範囲外として、テストだけに焦点を当てています。
      regression_tests_added50:
        description: >-
          プロジェクトは、過去6ヶ月以内に修正されたバグの少なくとも50％について、自動テスト スイートに回帰テストを追加しなければなりません。
      test_statement_coverage80:
        description: >-
          プロジェクトは、選択された言語でこの基準を測定できる少なくとも1つのFLOSSツールがある場合、少なくとも80％のステートメントカバレッジを提供するFLOSS自動テストスイートを備えていなければなりません。
        details: >-
          gcov/lcov、Blanket.js、Istanbul、JCov、<a href="https://cran.r-project.org/web/packages/covr/index.html">covr</a>
          (R) など、多くのFLOSSツールが、テストカバレッジを測定できます。この基準を満たすことは、テスト
          スイートが徹底していることを保証するものではないですが、それよりも、この基準を満たさないことは、貧弱なテスト
          スイートであることを示す強い指標であることに注意してください。
      test_policy_mandated:
        description: >-
          プロジェクトには、主要な新機能が追加されると、新しい機能のテストが自動化されたテスト スイートに追加されなければならないという正式な文書化されたポリシーがなければなりません。
      tests_documented_added:
        description: プロジェクトは、変更提案のための文書化された手順に、重要な新機能用にテストを追加するという方針を含まなければなりません。
      warnings_strict:
        description: プロジェクトによって作成されたソフトウェアにある警告に、実際的な場合には、最大限に厳格にならなければなりません。
      implement_secure_design:
        description: >-
          適用できる場合、プロジェクトはセキュア設計原則（「know_secure_design」から）を実装しなければなりません。プロジェクトでソフトウェアが作成されていない場合は、「該当なし」（N
          / A）を選択します。
        details: >-
          たとえば、プロジェクトの結果は、フェール セーフのデフォルト値を持つべきです（デフォルトではアクセスの決定は拒否されるべきで、プロジェクトのインストールはデフォルトでセキュリティ保護されているべきです）。また、完全なメディエーションであるべきです（制限されているすべてのアクセスは、権限がチェックされバイパス不可能でなければなりません）。原則が矛盾する場合があります。その場合、選択が必要です（たとえば、多くの仕組みは、「機構の節約」に反して複雑にすることも、単純にすることもできます）。
      input_validation:
        description: >-
          プロジェクトの結果は、潜在的に信頼できないソースからのすべての入力をチェックして有効であること（*allowlist*）を確認し、データに何らかの制限がある場合は無効な入力を拒否しなければなりません。
        details: >-
          攻撃者はしばしばブラックリストを回避することができるので、入力を "不正な形式" のリスト（別名*denylist*）と比較するのは、通常十分ではないことに注意してください。特に、数値は内部形式に変換され、最小値と最大値の間であるかがチェックされますし、文字列は、有効なテキストパターン（有効なUTF-8、長さ、構文など）であることを確認するためにチェックされます。一部のデータは「何でもよい」（たとえばファイル
          アップローダー）ことがありますが、通常はまれです。
      hardening:
        description: >-
          プロジェクトによって作成されたソフトウェアで強化メカニズムを使用するべきですので、ソフトウェア欠陥がセキュリティ上の脆弱性を引き起こす可能性が低くなります。
        details: >-
          強化メカニズムは、Content Security Policy（CSP）などのHTTPヘッダー、攻撃を緩和するコンパイラ
          フラグ（-fstack-protectorなど）、または未定義の動作を排除するためのコンパイラ フラグを含みます。私たちの目的のために、最低限の特権は強化メカニズムとはみなされません（最低の特権は重要ですが、別の話です）。
      crypto_weaknesses:
        description: >-
          プロジェクトによって作成されたソフトウェア内のデフォルトのセキュリティ メカニズムは、既知の重大な脆弱性を持つ暗号アルゴリズムやモード（たとえば、SHA-1暗号ハッシュ
          アルゴリズムまたはSSHのCBC モード）に依存してはいけません。
      crypto_algorithm_agility:
        description: >-
          プロジェクトは複数の暗号アルゴリズムをサポートするべきですので、ユーザーは破られた場合に素早く切り替えることができます。一般的な対称鍵アルゴリズムには、AES、Twofish、およびSerpentがあります。一般的な暗号化ハッシュ
          アルゴリズムには、SHA-2（SHA-224、SHA-256、SHA-384およびSHA-512を含む）およびSHA-3があります。
      crypto_credential_agility:
        description: >-
          プロジェクトは、他の情報（構成ファイル、データベース、ログなど）とは別にしたファイルに、認証資格情報（パスワードやダイナミックトークンなど）やプライベート暗号鍵を格納することをサポートしなければなりませんし、ユーザーがコードの再コンパイルなしにそれらを更新や置き換えできるように許可しなければなりません。プロジェクトが認証資格情報とプライベート暗号化鍵を決して処理しない場合は、「該当なし」（N/A）を選択します。
      crypto_used_network:
        description: >-
          プロジェクトで作成されたソフトウェアは、ネットワーク通信すべてに対して、SSHv2以降、TLS1.2以降
          (HTTPS)、IPsec、SFTP、SNMPv3などのセキュア プロトコルをサポートするべきです。FTP、HTTP、telnet、SSLv3以前、およびSSHv1などのセキュアでないプロトコルは、デフォルトで無効にし、ユーザーが特別に設定した場合のみ有効にするべきです。プロジェクトによって作成されたソフトウェアがネットワーク通信をサポートしない場合は、「該当なし」（N/A）を選択します。
      crypto_tls12:
        description: >-
          プロジェクトによって作成されたソフトウェアは、TLSをサポートあるいは使用する場合、少なくともTLSバージョン1.2をサポートするべきです。TLSの前身は、SSLと呼ばれていたことに注意して下さい。ソフトウェアがTLSを使用ない場合、「該当なし」（N/A）を選択します。
      crypto_certificate_verification:
        description: >-
          TLSをサポートしている場合、プロジェクトで作成されたソフトウェアは、TLSを使う時には、サブリソースを含めて、デフォルトでTLS認証を受けなければなりません。ソフトウェアがTLSを使用しない場合、「該当なし」（N/A）を選択します。
        details: >-
          誤ったTLS認証の検証は、よくある間違いであることに注意して下さい。詳細については、<a href="https://crypto.stanford.edu/~dabo/pubs/abstracts/ssl-client-bugs.html">「世界でもっとも危険なコード：非ブラウザー
          ソフトウェアでのSSL認証の検証」Martin Georgiev et al著</a> と <a href="https://blogs.gnome.org/mcatanzaro/2016/03/12/do-you-trust-this-application/">「このアプリケーションを信頼しますか？」Michael
          Catanzaro著</a>.を参照して下さい。
      crypto_verification_private:
        description: >-
          TLSをサポートしている場合、プロジェクトによって作成されたソフトウェアは、（たとえばセキュアクッキーなど）プライベートな情報をHTTPヘッダと共に送信する前に、証明書の検証をしなければなりません。ソフトウェアがTLSを使用しない場合は、「該当なし」（N/A）を選択します。
      signed_releases:
        description: >-
          プロジェクトは、広く普及することを意図しているプロジェクト結果のリリースには暗号で署名しなければなりませんし、パブリック署名鍵を入手して署名を検証する方法をユーザに説明するプロセスがなければなりません。これらの署名の秘密鍵は、ソフトウェアを一般に直接配布するために使用されるサイトにあってはなりません。リリースが広く普及することを意図していない場合は、「該当なし」（N/A）を選択します。
        details: >-
          プロジェクトの結果には、ソースコードと生成された成果物（実行可能ファイル、パッケージ、コンテナなど）が含まれます。生成された成果物は、ソースコードとは別に署名することができます。これらは、（暗号デジタル署名を使用して）署名付きgitタグとして実装できます。プロジェクトはgitのようなツールとは別に生成された結果を提供するかもしれませんが、そのような場合、別々の結果を別々に署名しなければなりません。
      version_tags_signed:
        description: >-
          バージョン管理システムでは、<a href="#signed_releases"> signed_releases
          </a>で説明されているように、重要なバージョンタグ（メジャーリリース、マイナーリリース、または公開されている脆弱性の一部であるタグ）を暗号署名して検証することが推奨されています。
      static_analysis_common_vulnerabilities:
        description: >-
          プロジェクトは、選択された言語でこの基準を実装できる少なくとも1つのFLOSSツールがある場合、解析された言語または環境で共通の脆弱性を探すためのルールまたはアプローチを備えた少なくとも1つの静的解析ツールを使用しなければならなりません。
      dynamic_analysis_unsafe:
        description: >-
          <em>もし</em>プロジェクトで作成されたソフトウェアにメモリ安全でない言語（CやC ++など）を使用して作成されたソフトウェアが含まれているならば、<em>そのときには</em>
          少なくとも1つの動的ツール（たとえば、ファジーまたはウェブ アプリケーション スキャナ）を、バッファの上書きなどのメモリの安全性の問題を検出するメカニズムと一緒にいつも使用します。プロジェクトがメモリ安全でない言語で書かれたソフトウェアを作成しない場合は、「該当なし」（N/A）を選択します。
      assurance_case:
        description: >-
          プロジェクトは、そのセキュリティ要件が満たされていることを証明する保証ケースを提供しなければならない。保証ケースには、脅威モデルの説明、信頼境界の明確な識別、セキュアな設計原則が適用されていることの議論、共通の実装セキュリティの弱点が対処されたことの議論が含まれなければならない。
        details: >-
          保証ケースは、「システムのプロパティに関する特定の一連の重大なクレームが、特定の環境とアプリケーションに対して適切に正当化されていることを説得力のある正当な議論で示す証拠」である（<a
          href="https://www.nist.gov/publications/software-assurance-using-structured-assurance-case-models">「構造化された保証ケースモデルを使用したソフトウェア保証」、Thomas
          Rhodes他、NIST Interagency Report 7608 </a>）。信頼境界は、データまたは実行がその信頼レベル、例えば、典型的なウェブアプリケーションにおけるサーバの境界、を変更する境界である。安全な設計原則（SaltzerやSchroeerなど）と一般的な実装セキュリティの弱点（OWASPトップ10やCWE
          / SANSトップ25など）をリストし、それぞれがどのように対抗しているかを示すのは一般的です。 <a
          href="https://github.com/coreinfrastructure/best-practices-badge/blob/master/doc/security.md">
          BadgeAppの保証ケース</a>は良い参考例になるかもしれません。これは、documentation_security、documentation_architecture、およびimplement_secure_designに関連しています。
      achieve_passing:
        description: プロジェクトは合格レベルバッジに達成しなければなりません。
    '2':
      bus_factor:
        description: プロジェクトは2以上の "バス ファクタ"を持つ必要があります。
      contributors_unassociated:
        description: プロジェクトには少なくとも2人の関係を持たない重要な貢献者がいなければなりません。
        details: >-
          同じ組織によって作業に対しに支払われ（従業員または請負業者）、組織がプロジェクトの成果の恩恵を受ける場合、貢献者は関連します。財務補助金が他の組織を通過する場合、同じ組織のものであると見なされません（例えば、共通の政府やNGOのソースから異なる組織に支払われた科学補助金は、貢献者を関連させません）。過去1年間にプロジェクトに些細でない貢献をしていれば、その人は大きな貢献をしています。重要な貢献者の良い指標の例としては、少なくとも1,000行のコード、50個のコミット、または少なくとも20ページの文書化が挙げられます。
      copyright_per_file:
        description: >-
          プロジェクトは、少なくとも1つの関連する年と著作権者を特定する著作権記述書を各ソースファイルに含まなければなりません（"[プロジェクト名]
          貢献者" のように ）。
        details: >-
          これは、各ファイルの先頭近くに以下のコメントを含めることによって行うことができます： "<tt>Copyright
          the [project name] contributors.</tt>"。<a href="https://www.linuxfoundation.org/blog/2020/01/copyright-notices-in-open-source-software-projects/"
          >"Copyright Notices in Open Source Software Projects"
          by Steve Winslow</a>を参照してください。
      license_per_file:
        description: >-
          プロジェクトは、各ソースファイルにライセンスステートメントを含まなければなりません。これは、各ファイルの先頭近くに次のコメントを含めることによって行うことができます：<a
          href="https://spdx.dev/ids/#how"><tt> SPDXライセンス識別子：[プロジェクトに対するSPDXライセンス表現]
          </tt> </a>
        details: >-
          これは、ライセンスを特定する自然言語での記述を含めることによっても行うことができます。プロジェクトには、ライセンス
          テキストまたは完全なライセンステキストを指し示す安定したURLを含めることもできます。 license_location基準は、プロジェクトライセンスが標準の場所にあることを要求します。
          SPDXライセンスの詳細については、<a href="https://github.com/david-a-wheeler/spdx-tutorial">このSPDXチュートリアル</a>を参照してください。
          <a href="#copyright_per_file"> copyright_per_file </a>との関係に注意してください。その内容は通常、ライセンス情報に先行します。
      repo_distributed:
        description: >-
          プロジェクトのソースリポジトリは、共通の分散バージョン管理ソフトウェア（gitやmercurialなど）を使用しなければなりません。
      small_tasks:
        description: プロジェクトは、新規または偶に参加する貢献者によって実行できる小さなタスクを明確に識別しなければなりません。
        details: |-
          この特定は、通常、課題トラッカーの選択された課題に対して、プロジェクトがそのために使用する1つまたは複数のタグ、たとえば、
          <a href="https://up-for-grabs.net/#/">up-for-grabs（誰でも使用可能）</a>、<a href="https://www.firsttimersonly.com/">first-timers-only（初心者専用）</a>、Small fix（小修正）、microtask（小タスク）、またはIdealFirstBug（理想的な最初のバグ）のいずれかをマークすることによって行われます。 これらの新しいタスクには機能を追加する必要はありません。ドキュメントを改善したり、テストケースを追加したり、プロジェクトを支援したり、プロジェクトの詳細を貢献者が理解できるようにすることができます。
      require_2FA:
        description: >-
          プロジェクトは、中央リポジトリを変更したり、機密データ（プライベート脆弱性レポートなど）にアクセスするために、開発者に対して二要素認証（2FA）を要求する必要があります。推奨されませんが、2FAメカニズムは、SMSのような暗号化メカニズムを持たないメカニズムを使用することができます。
      secure_2FA:
        description: >-
          プロジェクトの2要素認証（2FA）は、偽装を防ぐために暗号化メカニズムを使用すべきです。ショート メッセージ
          サービス（SMS）ベースの2FA自体は、暗号化されていないため、この基準を満たしていません。
        details: >-
          この基準を満たす2FAメカニズムは、一定時間後に変更される認証コードを自動的に生成するタイムベースのワン
          タイム パスワード（TOTP）アプリケーションです。 <a href="https://help.github.com/articles/configuring-two-factor-authentication-via-a-totp-mobile-app/">
          GitHubはTOTPをサポートしています</a>。
      code_review_standards:
        description: >-
          プロジェクトは、コードレビューの実施方法、チェックする必要があるもの、受け入れられる必要があるものなど、コードレビュー要件を文書化しなければなりません。
        details: >-
          <a href="#two_person_review"> two_person_review </a>とcontribution_requirementsも参照してください。
      two_person_review:
        description: >-
          プロジェクトは、公開する前に、提案されたすべての変更の少なくとも50％を著作者以外の人がレビューして、それが価値のある変更であり、取り込みに反対する既知の問題がないかどうかを判断しなければなりません。
      build_reproducible:
        description: >-
          プロジェクトが<a href="https://reproducible-builds.org/">再現可能なビルド</a>を持たなければなりません。ビルドが発生しない場合（たとえば、コンパイルされないでソースコードが直接使用されるスクリプト言語）、「該当なし」（N/A）を選択します。
        details: >-
          再現可能なビルドは、複数の当事者がソース ファイルから情報を生成するプロセスを独立にやり直し、ビット単位でまったく同じ結果を得られることを意味します。ある場合には、これ（再現可能なビルド）は、あるソート順を強いることで解決されます。Javaスクリプトの開発者は、npm
          shrinkwrapとwebpack OccurenceOrderPluginの使用を検討するかもしれません。GCCとclangのユーザーは、-frandom-seedオプションが有用であることを見つけるかもしれません。ビルド環境（ツールセットを含む）は、リビルドに使用できる特定のコンテナや仮想マシンの暗号化ハッシュを指定することによって、外部パーティのために、しばしば定義可能です。<a
          href="https://reproducible-builds.org/docs/">再現可能なビルド
          プロジェクトは、これを行う方法を記載したドキュメントを有します</a>。
      test_invocation:
        description: テストスイートは、その言語の標準的な方法で呼び出すことができなければなりません。
      test_continuous_integration:
        description: >-
          プロジェクトは、新しいコードまたは変更されたコードが頻繁に中央コードリポジトリに統合され、その結果に対して自動化されたテストが実行される、継続的な統合を実装しなければなりません。
        details: ほとんどの場合、これは、プロジェクトでフルタイムで働く各開発者が少なくとも1日に1回統合作業をすることを意味します。
      test_statement_coverage90:
        description: >-
          プロジェクトは、選択された言語でこの基準を測定できる少なくとも1つのFLOSSツールがある場合、少なくとも80％のステートメント
          カバレッジを提供するFLOSS自動テストスイートを備えていなければなりません。
      test_branch_coverage80:
        description: >-
          選択された言語でこの基準を測定できる少なくとも1つのFLOSSツールがあれば、少なくとも80％のブランチカバレッジを提供するFLOSS自動テストスイートがプロジェクトに存在しなければなりません。
      crypto_used_network:
        description: >-
          プロジェクトで作成されたソフトウェアは、ネットワーク通信すべてに対して、SSHv2以降、TLS1.2以降
          (HTTPS)、IPsec、SFTP、SNMPv3などのセキュア プロトコルをサポートしなければなりません。FTP、HTTP、telnet、SSLv3以前、SSHv1などのセキュアでないプロトコルは、デフォルトで無効にしておき、ユーザーが特別に設定した亜場合のみ有効にしなければなりません。プロジェクトによって作成されたソフトウェアがネットワーク通信をサポートしない場合は、「該当なし」（N/A）を選択します。
      crypto_tls12:
        description: >-
          プロジェクトによって作成されたソフトウェアは、TLSをサポートあるいは使用する場合、少なくともTLSバージョン1.2をサポートしなければなりません。TLSの前身は、SSLと呼ばれていたことに注意して下さい。ソフトウェアがTLSを使用ない場合、「該当なし」（N/A）を選択します。
      hardened_site:
        description: >-
          プロジェクトウェブサイト、リポジトリ（ウェブからアクセス可能な場合）、およびダウンロードサイト（別々の場合）には、許容できない値を持つキー強化ヘッダーが含まれていなければなりません。
        details: >-
          GitHubやGitLabはこれを満たしていることが知られているので注意してください。https://securityheaders.com/
          のようなサイトは、これをすぐに確認することができます。重要なセキュリティ強化ヘッダーは以下の通りです。Content
          Security Policy (CSP)、HTTP Strict Transport Security
          (HSTS)、X-Content-Type-Options (「nosniff」として)、および X-Frame-Options
          。Web ページからログインする機能のない完全に静的な Web サイトでは、いくつかの強化ヘッダーを省略してもリスクは少なくて済みますが、そのようなサイトを検出する信頼できる方法がないため、完全に静的なサイトであってもこれらのヘッダーが必要です。
      security_review:
        description: >-
          プロジェクトは過去5年間にセキュリティレビューを実施していなければなりません。このレビューは、セキュリティ要件とセキュリティ境界を考慮しなければならりません。
        details: >-
          これは、プロジェクトメンバーおよび/または独立した評価によって行うことができます。この評価は、静的および動的解析ツールによってサポートされることができますが、ツールが検出できない問題（特に設計上）を特定するためには、人間によるレビューが必要です。
      hardening:
        description: >-
          プロジェクトによって作成されたソフトウェアで強化メカニズムを使用しなければならないので、ソフトウェア欠陥がセキュリティ上の脆弱性を引き起こす可能性が低くなります。
      dynamic_analysis:
        description: >-
          プロジェクトは、リリース前にプロジェクトによって作成されたソフトウェアの主要な製品リリースに対して、少なくとも1つの動的解析ツールを適用しなければなりません。
      dynamic_analysis_enable_assertions:
        description: >-
          プロジェクトは、生成するソフトウェアに多くの実行時アサーションを含めるべきであり、動的分析中にそれらのアサーションをチェックするべきです。
      achieve_silver:
        description: プロジェクトは、シルバー レベル バッジを達成しなければなりません。
  static_pages:
    home:
      badge_program: OpenSSF ベストプラクティス バッジ プログラム
      get_your_badge: バッジを入手する
      p1_html: >-
        <a href="https://www.linuxfoundation.org/">Linux Foundation
        (LF)</a> Open Source Security Foundation (OpenSSF) ベストプラクティス
        バッジは、Free/Libre and Open Source Software（FLOSS）プロジェクトが、ベストプラクティスに従っていることを自ら示す方法です。プロジェクトは、このWebアプリケーションを使用して、それぞれのベストプラクティスに従っていることを説明することにより、自主的に無償で自己証明することができます。
        OpenSSF ベストプラクティス バッジは、GitHubのプロジェクトで利用可能な多くのバッジからインスピレーションを受けています。バッジの消費者は、どのFLOSSプロジェクトがベストプラクティスに従っているかを速やかに評価でき、その結果、より高品質で安全なソフトウェアを生産することができます。
      p2_html: >-
        <a href="/ja/criteria/0">バッジの合格基準はこちら</a>です。OpenSSF ベストプラクティス
        バッジ プログラムの詳細については、<a href='https://github.com/coreinfrastructure/best-practices-badge'>GitHubで公開</a>されています。
        <a href="/ja/project_stats">プロジェクトの統計情報</a>や<a href="/ja/criteria_stats">基準の統計情報</a>も確認できます。
        <a href="/ja/projects">プロジェクト ページ</a>には、参加しているプロジェクトが表示され、クエリも使用できます
        (「<a href="/ja/projects?gteq=100">合格バッジを持つプロジェクトだけ表示する</a
        >」クエリなど)。また、<a href='/ja/projects/1/0'>その例 (当プロジェクトのバッジ取得サイト)</a>
        も見ることができます。このプロジェクトは以前は Core Infrastructure Initiative
        (CII) Best Practices バッジという名で、もともとはCIIのもとで開発されたものですが、現在は<a
        href="https://openssf.org/" >Open Source Security Foundation
        (OpenSSF)</a> <a href="https://github.com/ossf/wg-best-practices-os-developers">
        Best Practices Working Group (WG)</a>に属しています。OpenSSFは、<a
        href="https://www.linuxfoundation.org/">Linux Foundation
        (LF)</a>傘下のファウンデーションです。同プロジェクトは、2021年12月24日付で、従来の "CII
        Best Practices badge" から正式に名称変更されました。
      p3_html: >-
        <em>プライバシーと法的問題</em>：<a href="https://www.linuxfoundation.jp/privacy">プライバシーポリシー</a>、
        <a href="/ja/cookies">クッキーについて</a>、および<a href="https://www.linuxfoundation.jp/terms">利用条件</a>をご覧ください。このバッジ
        アプリケーションのコード自体は、<a href="https://opensource.org/licenses/MIT">MIT</a>ライセンスのもとでリリースされています（バッジ取得を目指すプロジェクトは、それぞれのライセンスのもとで活動）。公開されているすべての非コード
        コンテンツは、少なくとも<a href="https://creativecommons.org/licenses/by/3.0/">Creative
        Commons Attribution License version 3.0 (CC-BY-3.0)</a>
        のもとでリリースされています。また、より新しい非コード コンテンツは、CC-BY version 3.0 以降
        (CC-BY-3.0+) のもとでリリースされています。詳細や不足事項については、OpenSSF ベストプラクティス
        バッジのコントリビューターまでご連絡ください。
      check_us_out: OpenSSF ベストプラクティス バッジのWebサイトをご覧ください！
      share_header_html: "<p>この情報を共有しましょう：</p>"
      twitter: Twitter
      reddit: Reddit
      facebook: フェイスブック
      linkedin: LinkedIn
      email: 電子メール
      projects_earned_badge: バッジを獲得したプロジェクト (一部)：
      hacker_news: ハッカーニュース
    cookies:
      cookies_header: クッキーについて
      cookies_info_html: >-
        <p>このサイトを適切に機能させるため、Cookieと呼ばれる小さなデータファイルを端末に配置することがあります。多くのウェブサイトがこれを行います。
        </p> <p> Cookieは、サイトにアクセスしたときにWebサイトがコンピュータ（モバイルデバイスを含む）に保存する小さなテキストファイルです。それによって、ウェブサイトは、一定期間に渡ってあなたの行動や好み（ログイン、言語、フォントサイズ、その他の表示設定など）を覚えておくことができるので、サイトに戻ったときやあるページから別のページへブラウズするときに再入力する必要がありません。
        Cookieは、World Wide Web（WWW）を実装するHTTPプロトコルの標準部分であり、<a href="https://tools.ietf.org/html/rfc6265">
        RFC 6265 </a>で規定されています。 </p> <p>ログインするたびにファーストパーティの「セッション」Cookieが使用されます。定義によって、セッションCookieは、ブラウザを終了するかログオフするときに期限切れになるように設計されています。
        「ログインしてください」（別名「私を覚えておいてください」）を有効にすると、ブラウザ上のファーストパーティの「永続的な」クッキーにも情報が保存されるため、ブラウザを終了した後でも、サイトを訪れたときに自動的にログインできます。このサイトへの認証に他のサイト（GitHubなど）を使用することを選択した場合、その別のサイトはおそらくCookieを使用します（したがって、Cookieを使用することも当てはまります）。私たちは他のサイトが何をするかを制御することはできないことに注意してください。
        </p> <p>設定したCookieは、このサイトに関連する機能をサポートするためにのみ使用されます。同意は取り消すことができます
        - ブラウザ上のCookieを削除するだけです。あなたはあなたが望むようにCookieを制御および/または削除することができます。詳細については、<a
        href="https://www.aboutcookies.org"> cookies.org </a>を参照してください。既にコンピュータ上にあるすべてのCookieを削除することができます。また、ほとんどのブラウザを設定して、それらが配置されないようにすることができます。ただし、これを行う場合は、サイトにアクセスするたびにいくつかの設定を手動で調整する必要があり、一部のサービスや機能が動作しない可能性があります。特に、このサイトへのログインは、（このサイトおよび他の多くのサイトの）セッションCookieに依存します。
        </p> <p>このテキストは、英国およびEUの「Cookie法」を遵守することを意図しています。 </p>
    error_404:
      heading: エラー404ページが見つかりません
      no_such_page: 申し訳ありません、そのようなページは存在しません。
      please_home: ホームページに行ってください。
    criteria_stats:
      criteria: 基準の統計
      project_stats_html: >-
        "アクティブ"な基準とは、パーセンテージ計算に含まれる基準です(「将来の」基準とは対照的です)。次の列は、MUST、SHOULD、SUGGESTEDの各レベルのアクティブな基準の数を識別します。回答として
        "N/A" を許可する、"適合" が回答の場合に正当な理由が必要、URLが必要、"適合" が回答の場合に正当な理由かURLが必要、詳細を含む、またはこのレベルは初めて。"将来"の基準はフォームに表示されており、将来的に何らかのレベルにアクティブな基準として追加されることが予想されますが、完了している計算には含まれていません。
        <br><br> プロジェクトに関する統計は、<a href="/ja/project_stats">プロジェクトの統計情報ページ</a>で確認できます。
      level: レベル
      must: 必要（MUST）
      should: すべきです（SHOULD）
      suggested: 推奨（SUGGESTED）
      total_active: アクティブなものの合計
      allow_na: 該当なし（N/A）を許可します
      require_url: URLが必要です
      details: 詳細を含みます
      future: 将来
      new_this_level: このレベルで新規
      met_justification_required: 適合の正当な理由が必要
      met_justification_or_url_required: 適合の正当な理由またはURLが必要
      see_actual_criteria: 実際の基準はこちらで確認できます。
    error_409:
      heading: エラー409：競合
      conflict: 申し訳ありませんが、複数のエントリがリクエストに一致し、競合が発生しています。
  headings:
    Accessibility and internationalization: アクセシビリティと国際化
    Analysis: 分析
    Automated test suite: 自動テスト スイート
    Basic project website content: 基本的なプロジェクト ウェブサイトのコンテンツ
    Basics: 基本的情報
    Bug-reporting process: バグ報告プロセス
    Change Control: 変更管理
    Coding standards: コーディング標準
    Documentation: ドキュメンテーション
    Dynamic code analysis: 動的コード分析
    Externally-maintained components: 外部で維持管理されるコンポーネント
    Future: 今後追加されるバッジ基準
    future: 今後追加されるバッジ基準
    Installation system: インストールシステム
    New functionality testing: 新機能テスト
    Other: その他
    Other security issues: その他のセキュリティ上の課題
    Previous versions: 以前のバージョン
    Project oversight: プロジェクトの管理・運営
    Public version-controlled source repository: 公開されたバージョン管理ソースリポジトリ
    Publicly known vulnerabilities fixed: 広く知られた脆弱性を修正
    Quality: 品質
    Release notes: リリースノート
    Reporting: 報告
    Secure development knowledge: セキュリティに関する開発知識
    Secure release: 公開物の安全性
    Secured delivery against man-in-the-middle (MITM) attacks: MITM（man-in-the-middle：中間者）攻撃に対応できる安全な配信
    Security: セキュリティ
    Static code analysis: 静的コード解析
    Unique version numbering: 一意的なバージョン番号
    Use basic good cryptographic practices: 優良な暗号手法を使用する
    Vulnerability report process: 脆弱性報告プロセス
    Warning flags: 警告フラグ
    Working build system: 作業ビルドシステム
    Identification: 識別情報
    Prerequisites: 前提要件
    FLOSS license: FLOSSライセンス
  last_entry: 最後の翻訳エントリ
  admin_only: 管理者のみ。
  criterion_status:
    Met: 適合
    Unmet: 不適合
    NA: 該当なし
  error_messages:
    need_home_page_or_url: 少なくともホームページかリポジトリのURLが必要です
    form_contains:
      one: フォームは、1つのエラーを含んでいます。
      other: フォームは、%{count}エラーを含んでいます。
      few: フォームは、%{count}エラーを含んでいます。
      many: フォームは、%{count}エラーを含んでいます。
    not_an_email: " 電子メールではありません"
    known_bad_password: " よく知られている（悪い）パスワードです"
    valid_text: |-
       有効なUTF-8エンコーディングを持つ必要があり、無効な制御文字は必要ありません
      文字
    url_message: " http：またはhttps：で始めて、制限付きの文字セットを使用する必要があります"
  criteria_overall:
    beginning_header_all: FLOSSベストプラクティス基準（すべてのレベル）
    beginning_header_0: FLOSSベストプラクティス基準（合格バッジ）
    beginning_header_1: FLOSSベストプラクティス基準（シルバー バッジ）
    beginning_header_2: FLOSSベストプラクティス基準（ゴールド バッジ）
    beginning_all_html: >-
      <p>これは、合格、シルバー、およびゴールドバッジ レベルで Open Source Security Foundation
      (OpenSSF) ベストプラクティス バッジを達成するための、フリー/リブレおよびオープンソース ソフトウェア（FLOSS）プロジェクトのベストプラクティスのセットです。このリストは、<a
      href="/ja/criteria">基準のみ</a>または<a href="/ja/criteria?details=true&rationale=true">追加情報</a>とともに表示できます。
      <a href="/ja/criteria/0">合格</a> 、 <a href="/ja/criteria/1">シルバー</a>
      、 <a href="/ja/criteria/2">ゴールド</a>の基準だけでなく、 <a href="/ja/criteria_stats">基準の統計</a>も表示できます。
    beginning_0_html: >-
      <p>これは、Open Source Security Foundation (OpenSSF) ベストプラクティスのシルバーバッジを達成するための、フリー/リブレおよびオープンソースソフトウェア（FLOSS）プロジェクトのベストプラクティスのセットです。このリストは、<a
      href="/ja/criteria/0">基準のみ</a>または<a href="/ja/criteria/0?details=true&rationale=true">追加情報</a>とともに表示できます
      。 <a href="/ja/criteria">条件の完全なセット</a>も利用できます。
    beginning_1_html: >-
      <p>これは、Open Source Security Foundation (OpenSSF) ベストプラクティスのシルバーバッジを達成するための、フリー/リブレおよびオープンソース
      ソフトウェア（FLOSS）プロジェクトのベストプラクティスのセットです。このリストは、<a href="/ja/criteria/1">基準のみ</a>または<a
      href="/ja/criteria/1?details=true&rationale=true">追加情報</a>とともに表示できます
      。 <a href="/ja/criteria">条件の完全なセット</a>も利用できます。
    beginning_2_html: >-
      <p>これは、Open Source Security Foundation (OpenSSF) ベストプラクティスのシルバーバッジを達成するための、フリー/リブレおよびオープンソース
      ソフトウェア（FLOSS）プロジェクトのベストプラクティスのセットです。このリストは、<a href="/ja/criteria/2">基準のみ</a>または<a
      href="/ja/criteria/2?details=true&rationale=true">追加情報</a>とともに表示できます
      。 <a href="/ja/criteria">条件の完全なセット</a>も利用できます。
    see_discussion_html: >-
      <p>これらの基準の詳細については、 <a href="/ja/criteria_discussion">基準の説明</a>を参照してください。
    future: "{将来}"
    na_allowed: "{N/A allowed}"
    na_justification_required: "{N/A justification}"
    met_justification_required: "{Met justification}"
    met_url_required: "{Met URL}"
  criteria_discussion:
    intro_p01_html: "<h1 id='criteria_discussion'>基準の説明</h1>"
    intro_p02_html: >-
      <p> ソフトウェアに欠陥や脆弱性がないことを<i>保証</i>できる一連のプラクティスはありません。正式な手法であっても、仕様や仮定が間違っていれば失敗する可能性があります。また、プロジェクトが健全で機能的な開発コミュニティを維持することを保証できる一連のプラクティスもありません。</p>
    intro_p03_html: >-
      <p> しかし、ベストプラクティスに従うことで、プロジェクトの成果を向上させることができます。たとえば、リリース前に複数人によるレビューを可能にするプラクティスもあります。これは、発見しにくい技術的な脆弱性を発見するのに役立ち、異なる組織の開発者の間で信頼を築き、繰り返しやりとりすることができます。</p>
    intro_p04_html: >-
      <p>このページでは、Open Source Security Foundation (OpenSSF) のベストプラクティス
      バッジのために開発された、Free/Libre and Open Source Software (FLOSS)
      プロジェクトのためのベストプラクティスのセットについて説明します。これらのベストプラクティスに従っているプロジェクトは、自主的に自己認証を行い、関連するバッジを達成したことを示すことができます。プロジェクトは、Webアプリケーション
      (BadgeApp) を使用して、どのようにしてこれらのベストプラクティスとその詳細な基準を満たしているかを説明することで、無料でこれを行うことができます。</p>
    intro_p05_html: "<p>これらのベストプラクティスは、以下の目的で作成されました。</p>"
    intro_p06_html: >-
      <ol> <li>プロジェクトがベストプラクティスに従うことを奨励する。</li> <li>新しいプロジェクトがそれらのプラクティスを発見するのを助ける。</li>
      <li>どのプロジェクトがベストプラクティスに従っているのかをユーザーが知るのに役立つ（結果としてユーザーがそのようなプロジェクトを好むようになる）。</li>
      </ol>
    intro_p07_html: >-
      <p> イディオム「ベストプラクティス」とは、「組織、業界などで推奨または標準と見なされる手順または一連の手順」を意味します。
      （出典：<a href="http://www.dictionary.com/browse/best-practice"
      rel="nofollow">Dictionary.com</a>）。これらの基準は、より広いFLOSSコミュニティで広く「推奨または標準と見なされている」と私たちが信じているものです。</p>
    intro_p08_html: >-
      <p>これらの基準がどのように開発されたかの詳細については、<a href="https://github.com/coreinfrastructure/best-practices-badge"
      >OpenSSF Best PracticesバッジGitHubサイト</a>を参照してください。</p> <p>また、<a
      href="/ja/criteria">完全な基準を見る</a>こともできます。</p>
    structure_p01_html: "<p></p> <h2 id='criteria_structure'>基準の構造</h2>"
    structure_p02_html: >-
      <p> ベストプラクティスの基準は次の3レベルに分かれています。<ul> <li><b>Pass（合格）</b>は、適切に実行されているFLOSSプロジェクトが通常従うベストプラクティスに焦点を当てています。合格バッジを取得することは成果です。バッジを追求しているプロジェクトのうち、一度で合格レベルに達成するプロジェクトはわずか10%ほどです。<li><b>Silver（シルバー）</b>
      はPassよりも厳しい基準ですが、小規模で単一組織のプロジェクトによって達成できるでしょう。<li><b>Gold（ゴールド）</b>はシルバーよりもさらに厳しく、小規模または単一組織のプロジェクトでは達成できない基準が含まれています。</ul>
    structure_p03_html: "<p> 各基準には短い名前が付けられており、基準テキストの後の角括弧内に上付きのテキストとして表示されています。"
    other_p01_html: "<p></p> <h2 id='criteria_other_projects'>他のプロジェクトとの関係</h2>"
    other_p02_html: >-
      <p>Linux Foundationは、「高品質のフリーおよびオープンソース ソフトウェア（FOSS）コンプライアンス
      プログラム」の基準を特定する <a href="https://www.openchainproject.org/"
      rel="nofollow">OpenChain Project</a>も後援しています。OpenChainは、組織がFLOSSを最適に使用し、FLOSSプロジェクトに貢献する方法に焦点を当てていますが、OpenSSFベストプラクティス
      バッジは、FLOSSプロジェクト自体に焦点を当てています。 OpenSSFベストプラクティス バッジとOpenChainは連携して、FLOSSとFLOSSの使用方法を改善します。</p>
    automation_p01_html: "<p></p> <h2 id='criteria_automation'>基準の自動化</h2>"
    automation_p02_html: >-
      <p> 場合によっては、プロジェクトが標準の規則に従っていて、適切なAPIサポートを備えたサイト（GitHubなど）でホストされている場合、情報を自動的にテストして入力します。</p>
    automation_p03_html: "<p>将来的には、この自動化を改善する予定です。自動化の改善は大歓迎です！</p>"
    automation_p04_html: >-
      <p>ただし、手頃な価格で自動化できない場合でも、意図的に「重要なこと」を優先しています。自動測定は確かに素晴らしいですが、重要なものをすべて自動化できるわけでも、手頃な価格で自動化できるわけでもありません。</p>
    changes_p01_html: "<p></p> <h2 id='criteria_changes'>時間の経過による変化</h2>"
    changes_p02_html: |-
      <p>
      これらの慣行とその詳細な基準は、時間の経過とともに更新されることを期待しています。新しい基準を追加する予定ですが、それを「将来の」基準としてマークしておくことで、プロジェクトがその情報を追加してバッジを維持できるようにします。</p>
    changes_p03_html: >-
      <p>フィードバックは<em>大歓迎です</em>。<a href="https://github.com/coreinfrastructure/best-practices-badge"
      >GitHubサイトからイシューやプルリクエスト</a>で提出してください。<a href="https://lists.coreinfrastructure.org/mailman/listinfo/cii-badges"
      rel="nofollow">一般的な議論のためのメーリング リスト</a>もあります。</p>
    keywords_p01_html: "<p></p> <h2 id='keywords'>キーワード</h2>"
    keywords_p02_html: >-
      <p>このドキュメントの英語のキーワード、"MUST"、"MUST NOT"、 "SHOULD"、"SHOULD
      NOT"、および "MAY" は、<a href="https://tools.ietf.org/html/rfc2119"
      rel="nofollow">RFC 2119</a> で説明されているように解釈されます。"SUGGESTED"
      も追加されています。要約すると、これらのキーワードには次の意味があります。</p>
    keywords_p03_html: |-
      <ul>
      <li>MUST（～なければならない）は絶対的な要件であり、MUST NOT（～してはならない）は絶対的な禁止です。</li>
    keywords_p04_html: >-
      <li>SHOULD（～べきである）という用語は、通常必要とされる基準を示しますが、特定の状況ではそれを無視する正当な理由が存在する場合があります。ただし、別のコースを選択する前に、完全な影響を理解し、慎重に検討する必要があります。</li>
    keywords_p05_html: >-
      <li>基準を考慮する必要がある場合は、SHOULDの代わりにSUGGESTED（推奨される）という用語が使用されますが、SHOULDよりもさらに一般的に「そうしない正当な理由」が存在します。</li>
    keywords_p06_html: |-
      <li>MAY（～ことができる）という用語は、記述された実装が受け入れ可能であることを明確にするためなど、何かを行うことができる方法の一つを提供します。
      </li> </ul>
    keywords_p07_html: >-
      <p>実装が困難な場合や、実装コストが高い可能性がある場合は、実行するべきである（SHOULD）や、推奨される（SUGGESTED）と記述されます。</p>
    achieving_p01_html: "<p></p> <h2 id='criteria_achieving_badge'>バッジの取得</h2>"
    achieving_p02_html: >-
      <p>バッジを取得するには、すべてのMUSTおよびMUST NOTの基準については「満たしている必要があり」、すべてのSHOULDの基準については「満たしているか、正当な理由で満たしていない必要があり」、そしてすべてのSUGGESTEDの基準については、「考慮している必要がある（満たしているか満たしていないかを評価されるが、時に明記されていない限り正当な理由は必要ない）」となります。N/A（「該当しない」）の回答は、これが許可されている場合は、「満たしている」と同じと見なされます。場合によっては、特に上位レベルでは、正当化やURLが必要になることがあります。</p>
    achieving_p03_html: >-
      <p> 一部の基準には、これに影響を与える特別なマークがあります。<ul> <li><b>{N/A allowed}</b>
      - "N/A" ("該当しない") が許可されている。<li><b>{N/A justification}</b>
      - "N/A" ("該当しない") が許可されているが、正当な理由が必要。<li><b>{Met justification}</b>
      - "適合" には正当な理由が必要。<li><b>{Met URL}</b> - "適合" にはURLによる正当化が必要。<li><b>{Future}</b>
      - この基準への回答は現在は効果がないが、将来必要になる可能性がある。</ul>
    achieving_p04_html: >-
      <p> プロジェクトは、次のレベルを達成するために前のレベルを達成する必要があります。場合によっては、SHOULD基準がより高いレベルのバッジではMUSTになり、低レベルのSUGGESTED基準がより高いレベルのバッジではSHOULDまたはMUSTになることもあります。また、基準が<i>どのように</i>満たされているかを他の人に理解してもらいたいため、高レベルのバッジにはより多くの正当性が求められます。</p>
    achieving_p05_html: >-
      <p>一部のソフトウェアは暗号化機能を直接使用する必要がないため、（多くの）暗号化基準が常に適用されるとは限りません。そのような場合は、N/Aと答えてください。</p>
    achieving_p06_html: >-
      <p>暗黙の合格基準が1つあります。すべてのプロジェクトには、安定したURLを持つ公開Webサイトが必要（MUST）です。これは、最初にバッジエントリを作成するために必要です。</p>
    terminology_p01_html: "<p></p> <h2 id='criteria_terminology'>用語</h2>"
    terminology_p02_html: >-
      <p>ソフトウェア開発やFLOSSプロジェクトの実行に慣れていない場合は、<a href="http://producingoss.com/"
      rel="nofollow">KarlFogelによる<em>オープンソース ソフトウェアの作成</em></a>などの資料が役立つ場合があります。</p>
    terminology_p03_html: "<p>重要な用語をいくつかご紹介します。</p><ul>"
    terminology_p04_html: >-
      <li>A <em>プロジェクト</em>は、プロジェクトメンバーがいて、プロジェクト結果を生成するアクティブなエンティティです。そのメンバーは、プロジェクトサイトを使用して、結果を調整および配布します。プロジェクトは正式な法人である必要はありません。</li>
    terminology_p05_html: >-
      <li>プロジェクト <em>メンバー</em>は、プロジェクトの結果を生み出すために協力する1人以上の人々または企業のグループです。一部のFLOSSプロジェクトには、さまざまな種類のメンバーとさまざまな役割がありますが、それは私たちの範囲外です。</li>
    terminology_p06_html: >-
      <li>プロジェクト<em>の成果物</em>は、プロジェクト メンバーが協力して最終目標として作成するものです。通常、これはソフトウェアですが、プロジェクトの結果には他のものも含まれる場合があります。
      「プロジェクトによって作成されたソフトウェア」を参照する基準は、プロジェクトの成果物を参照しています。</li>
    terminology_p07_html: >-
      <li>プロジェクト <em>サイト</em>は、プロジェクトの成果物の開発・普及を支援するためのサイトであり、プロジェクトのWebサイト、リポジトリ、ダウンロード
      サイトなどが含まれます（<a href="#sites_https">sites_https</a>を参照)。</li>
    terminology_p08_html: >-
      <li>プロジェクトの<em>Webサイト</em>、別名プロジェクトのホームページは、新規ユーザーがプロジェクトの情報を見るために訪れるワールドワイドウェブ（WWW）上のメインページです。プロジェクトのリポジトリ
      サイトと同じである可能性があります（GitHubなど）。</li>
    terminology_p09_html: >-
      <li>プロジェクト <em>リポジトリ</em>は、プロジェクトの成果物とその成果物の改訂履歴を管理・保存します。自動生成された成果物ではなく、編集可能なバージョンの管理・保存のみを行うことを求めているため、プロジェクトの<em>ソース
      リポジトリ</em>とも呼ばれています（生成された成果物はリポジトリに保存されていないことが多い）。</li>
    terminology_p10_html: >-
      <li><em>プロジェクトのセキュリティ メカニズム</em>提供されたプロジェクトのソフトウェアによって提供されるセキュリティ
      メカニズムです。</ul>
    noncriteria_p01_html: "<p></p> <h2 id='criteria_noncriteria'>基準に含まれないもの</h2>"
    noncriteria_p02_html: "<p> 基準とは：<ul>"
    noncriteria_p03_html: >-
      <li>特定のテクノロジー、製品、またはサービスを<em>必要としません</em>。たとえば、git、GitHub、GitLabは<em>必要ありません</em>。基準は、一般的なケースのガイダンスとヘルプを<em>提供します</em>。その情報は、人々が基準を理解して満たすのに役立つためです。
      gitまたはGitHubを使用するプロジェクトには、これらの一般的なケースでユーザーを支援するための特別な自動化がいくつかありますが、<em>必須ではありません</em>。したがって、新しいツールと機能が利用可能になると、プロジェクトはすぐにそれらに切り替えることができます。例外として、基準にはプロジェクトのWebページとTLSが必要です。
    noncriteria_p04_html: >-
      <li>特定のプログラミング言語を要求したり禁止したり<em>しません</em>。特定の<em>種類</em>のプログラミング言語に対して追加の対策をとることを要求しますが、それは別のことです。
    noncriteria_p05_html: >-
      <li>プロプライエタリなソフトウェア、プロプライエタリなサービス、プロプライエタリな技術の使用を<em>決して</em>要求しません。多くの<a
      href="https://www.gnu.org/philosophy/free-sw.en.html" rel="nofollow">フリー
      ソフトウェア</a>開発者はそのような基準を拒否するからです。プロジェクトがそれらを使用し依存することは<em>許可されます</em>。
    noncriteria_p06_html: >-
      <li>プロジェクト内での積極的な開発やユーザー ディスカッションは<em>必要ありません</em>。一部の高度に成熟したプロジェクトはめったに変更されないため、ほとんどアクティビティがない場合があります。ただし、この基準では、脆弱性がプロジェクトに報告された場合にプロジェクトが応答する<em>必要があります</em>。
    noncriteria_p07_html: "<li>バッジを取得するための料金は<em>必要ありません</em>。</li>"
    noncriteria_p08_html: >-
      <li>すべての基準を一度に実装する<em>必要はありません</em>。ほとんどのプロジェクトは、時間をかけて実装しています。</ul>
    noncriteria_p09_html: >-
      <p> 合格レベルの基準には、たとえば多額の資金を必要とするものなど、1人で行うプロジェクトでは現実的ではないような基準は含まれていません。多くのFLOSSプロジェクトは小規模であり、彼らの権利を奪うことは避けたいと考えています。
    identify_p01_html: "<p></p> <h2 id='criteria_id_project'>プロジェクトの特定</h2>"
    identify_p02_html: >-
      <p> 私たちのアプリケーションはすべてのプロジェクトエントリに一意のIDを与えますが、それはプロジェクトを検索する人々を助けません。アプリケーションにとって、プロジェクトの<em>実</em>名はそのリポジトリのURLであり、それが利用できない場合は、プロジェクトの「フロントページ」のURLです。このURLへの変更をレート制限して、無意味な変更を防止しています。通常、プロジェクトには人間が読める名前が付いていますが、これらの名前は一意ではありません。<p></p>
    criteria_why_p01_html: "<p></p> <h2 id='criteria_why'>なぜ基準があるのか?</h2>"
    criteria_why_p02_html: >-
      <p>論文<a href="http://www.researchinlearningtechnology.net/index.php/rlt/article/view/23563"
      rel="nofollow">Open badges for education: what are the implications
      at the intersection of open systems and badging?（教育のためのオープン
      バッジ：オープン システムとバッジ機能の接点がもたらす成果）</a>では、バッジシステムが有効な一般的な理由として、以下の3つを挙げています（すべて当てはまります）。</p><ol>
    criteria_why_p03_html: >-
      <li>バッジは行動の動機づけになります。ベストプラクティスを特定することで、それらのベストプラクティスをまだ実行していないプロジェクトにその実行を推奨します。</li>
    criteria_why_p04_html: >-
      <li>教育ツールとしてのバッジ。一部のプロジェクトは、他のプロジェクトによって適用されたベストプラクティスのいくつか、またはそれらを実際に適用する方法を認識していない場合があります。バッジは、彼らがそれらとそれらを実装する方法を認識するのに役立ちます。</li>
    criteria_why_p05_html: >-
      <li>シニフィアン（記号表現）やクレデンシャルとしてのバッジ。潜在的なユーザーは、ベストプラクティスを適用しているプロジェクトを使用して、一貫して良好な結果を生み出したいと考えています。バッジを使用すると、プロジェクトがベストプラクティスに従っていることを簡単に示すことができ、ユーザーはどのプロジェクトがそれを行っているかを簡単に確認できます。</li>
      </ol>
    self_certification_p01_html: <h3 id="criteria_self_certification">なぜ自己認証なのか？</h3>
    self_certification_p02_html: >-
      <p> 私たちが自己認証を採用した理由は、多くのプロジェクト（小さなプロジェクトであっても）が参加できるようにするためです。何百万ものFLOSSプロジェクトがあり、サードパーティにお金を払って個々に評価することはできません。プロジェクトが虚偽の主張をするリスクはありますが、そのリスクは小さく、ユーザーが自分で主張を確認でき、虚偽の主張を無効にすることができます。また、自動化を使用して虚偽の主張を無効にできるため、結果に自信を持つことができます。</p>