---
zh-CN:
  helpers:
    select:
      prompt: 请选择
    submit:
      create: 新增%{model}
      update: 更新 %{model}
      submit: 保存 %{model}
  hello: 你好，世界
  projects_count:
    one: "%{count} 项目"
    other: "%{count} 项目"
    zero: 零项目
    few: "%{count}个项目"
    many: "%{count}个项目"
  feed_title: CII最佳实践徽章计划更新项目
  layouts:
    cii_best_practices: CII最佳实践
    projects: 项目
    users: 用户
    profile: 资料
    settings: 设置
    logout_html: "<span class =“glyphicon glyphicon-log-out”></span>
      注销"
    signup_html: <span class="glyphicon glyphicon-user"></span>
      注册
    login_html: <span class="glyphicon glyphicon-log-in"></span>
      登录
    footer_text_html: >-
      <small> <strong>需要帮助？有疑问？发现问题？请 <a href="mailto:&#99;ii&#45;badges&#45;questions&#45;own&#101;r&#64;lists&#46;coreinfrastructure&#46;or&#103;">发送邮件</a>
      或 <em><a href="https://github.com/coreinfrastructure/best-practices-badge/issues"
      target="_blank">提出问题</a></em>.</strong> © 2015-2017 <a href="https://www.coreinfrastructure.org/"
      target="_blank">Core Infrastructure Initiative （核心基础设施计划）</a>,
      一个 <a href="https://www.linuxfoundation.org/" target="_blank">Linux
      基金会</a> 合作项目。版权所有。 请查阅我们的 <a href="https://www.linuxfoundation.org/privacy"
      target="_blank">隐私策略</a> 和 <a href="https://www.linuxfoundation.org/terms"
      target="_blank">使用条款</a>. </small>
    account: 帐户
    choose_locale: 选择区域设置
  sessions:
    login_header: 登录
    login_with_github_html: <span class="fa fa-github"></span>
      使用GitHub账户登录
    or: 或
    email: 电子邮件
    password: 密码
    forgot_password: 忘记密码了吗？
    remember_me: 记住我
    login_custom: 使用自定义帐户登录
    no_custom: 没有自定义帐号？立即注册！
    already_logged_in: 您已经登录。
    incorrect_login_info: 登录信息不正确
    invalid_combo: 电子邮件或者密码不正确
    signed_in: 已登录！
    not_activated: 帐户未激活。检查您的电子邮件中的激活链接。
    signed_out: 已退出！
    cookie_details_html:
  users:
    new:
      signup_header: 注册
      intro_html: >-
        如果您不想使用GitHub账户，您可以在此注册。<br><br> 如果您没有收到激活链接，请重新注册，我们将发送新的激活链接。
      name: 名称
      email: 电子邮件
      password: 密码
      password_confirmation: 确认密码
      create_account: 创建我的账户
      preferred_locale: 首选语言
      intro_github: 如果您有GitHub账户，可以使用该账户登录。
    show:
      see_external: 查看此用户的外部页面。
      other_projects_edit: 其他您可以编辑的项目
      as_admin: 作为管理员，您还可以：
      send_email_to: 发送电子邮件至：
      delete_link_name: 删除
      confirm_delete: 您确定要删除此用户吗？
      edit_user: 编辑用户
      projects_owned: 拥有的项目：
      projects_additional_rights: 具有额外权力的项目：
      is_admin: 该用户是徽章应用管理员。
    update:
      profile_updated: 资料已更新
    destroy:
      cannot_delete_self: 不能删除自己。
      user_deleted: 用户已被删除。
    redirect_existing: 该用户已经存在。您的意思是登录吗？
    new_activation_link_created: 新的激活链接已经创建。请检查您的电子邮件以激活您的帐户。
    please_log_in: 请登录。
    edit:
      update_user_info: 更新用户信息
      save_changes: 保存更改
  project_stats:
    index:
      project_stats_header: 项目统计
      all_projects: 所有项目
      projects_nontrivial: 具有显著进展的项目
      projects_activity_30: 在过去30天内有徽章项活动的项目
      daily_activity: 每日徽章项活动
      reminders: 提醒
      admin_html: 作为管理员，您还可以查看<a href="/reminders">有关提醒的详细信息</a>。
      raw_data: 您还可以查看原始数据：
      json_format: JSON格式
      csv_format: 可下载的CSV格式
      active_projects: 活跃项目（30天内创建/更新）
      active_in_progress: 正在进行中的项目（在30天内创建/更新）
      active_edited: 活跃编辑的项目（30天内有更新）
      active_edited_in_progress: 活跃编辑的认证中项目（30天内有更新）
      projects_created_since_yesterday: 自前一天创建的项目
      projects_updated_since_yesterday: 项目从前一天更新
      reminders_sent_since_yesterday: 自昨天起发送的提醒
      reactivated_projects: 收到提醒后14天内重新启动的项目
      projects_created_average_7_days: 项目创建平均超过7天
      projects_updated_average_7_days: 项目更新平均超过7天
      projects_created_updated_daily: >-
        数据集“一天前创建的项目”是在给定日期时间的24小时内创建的项目数量（不包括在同一24小时内也被删除的项目）的一组计数。类似地，数据集“一天前编辑的项目”是在给定日期时间的24小时内（不包括在同一24小时内创建或删除的项目）中的一组计数。
        7天平均值显示7天的相应平均值。您可以在图例中选择颜色来隐藏和取消隐藏相应的数据。
      projects_silver: 有银级徽章进展的项目
      projects_gold: 有金级徽章进展的项目
      projects_completed_silver_and_gold: 完成银级徽章和金级徽章的项目
      percent_projects_earning_badges: 获取徽章的项目百分比
  projects:
    index:
      add_link: 添加
      add_new: 添加新项目
      badge_status: 徽章状态
      exclude_passing: 排除已通过的
      text_search: 文本搜索
      name_or_description: 名称或说明文字
      search: 搜索
      all: 所有
      passing_100: 通过（100％）
      in_progress_variable: 正在进行中（%{percent}％以上）
    table:
      id: Id
      name: 名称
      description: 描述
      website: 网站
      license: 授权
      owner: 所有者
      last_achieved: 最后达成
      pachieved: "% 已达成"
      can_also_sort: 您也可以按以下方式排序：
      repository_url: 仓库网址
      create_time: 创建时间（徽章认证的）
      update_time: 最后更新时间（徽章条目）
      user_id: 用户名
      paren_name_unknown: "(未知名称)"
      badge_level: 项目%{id}的徽章级别为%{percent}%
    new:
      post_delay_warning: 在提交后，因为我们试图自动填充相关信息，可能有显著的滞后。
      new_badge: 新徽章
      may_select_html: 您可以从GitHub仓库中选择<em>或</em>提供其他有关项目的信息。
      select_one_github: 从GitHub仓库中选择
      submit_github: 提交GitHub仓库
      url_of_homepage: 项目主页的URL （项目整体的）？以 http(s):// 开头 （很多字符不允许，包含
        "?"）
      placeholder_of_homepage: http(s)://... 项目主页 URL
      url_of_repo: 版本控制仓库的URL （可以和项目主页相同）？ 以 http(s):// 开头（很多字符不允许，包含
        "?"）
      placeholder_of_repo: http(s)://... 项目仓库 URL
      submit_urls: 提交网址
      sign_in_first: 请登录以添加项目！
      thanks_adding: 感谢您添加项目！请填写其余信息以获取徽章。
      project_already_exists: 这个项目已经存在！
      final_text_html: 注意 - 如果您的存储库URL位于GitHub上，则任何可以提交到存储库的人都可以编辑徽章信息。
      new_badge_or: 或
      original_repos: "=>原始GitHub仓库"
      fork_repos: "=> 分支GitHub仓库"
    show:
      edit: 编辑
      delete: 删除
      confirm_delete: 您确定要删除整个项目： %{project_id} 吗？
      back: 后退
      cc_by_3plus_html: >-
        此数据在<a href="https://creativecommons.org/licenses/by/3.0/us"
        target="_blank">知识共享署名3.0或更高版本许可证（CC-BY-3.0 +）</a> 下可用。所有内容都可以自由分享和演绎，但必须给予适当的署名。请署名为%{user}和CII最佳实践徽章贡献者。<br><br>
      cc_by_3only_html: >-
        此数据在<a href="https://creativecommons.org/licenses/by/3.0/us"
        target="_blank">知识共享署名3.0版本许可证（CC-BY-3.0）</a>下可用，并依据<a
        href="https://www.coreinfrastructure.org/" target="_blank">核心基础设施计划</a>
        <a href ="https://www.linuxfoundation.org/terms" target="_blank">使用条款</a>。所有数据都可以自由分享和演绎，但必须给予适当的署名。请署名%{user}和CII最佳实践徽章贡献者。<br>
        <br>
      owned_by: 项目徽章条目拥有者：
      created_at_html: "<strong>最后更新于</strong> %{when},"
      updated_at_html: "<strong>最后更新于</strong> %{when}。"
      last_lost_html: 最后在%{when}丢失通过徽章。
      last_achieved_html: 最后在 %{when} 获得通过徽章。
    edit:
      submit_cc_by_3plus_html: >-
        通过提交有关该项目的数据，您同意至少在<a href="https://creativecommons.org/licenses/by/3.0/us"
        target="_blank">知识共享署名3.0或更高版本许可证（CC-BY-3.0 +）</a>下发布。这意味着所有人都可以自由分享和演绎，但必须给予适当的署名。您保留版权（如果有），并且项目许可证不受影响。<br><br>
      save_and_continue: 保存（并继续）
      submit_and_exit: 提交（并退出）
      repo_url_limits: 您只能将repo_url从http更改为https
      changed_since_html: >-
        您访问编辑表单后，另一位用户对该记录进行了更改。 <br>请打开一个新的<a href="%{edit_url}"
        target="_blank">编辑表单</a>来转移您的更改。
      successfully_updated: 项目成功更新。
      congrats_new: >-
        恭喜获得%{new_badge_level}徽章！如果您还没有，请在您的项目页面上显示您的徽章状态（如果您不知道如何操作，请参阅下面的“如何嵌入”文本）。
      lost_badge: 项目已经失去了徽章。
      static_analysis_updated_html: >-
        我们更新了<a href="#static_analysis"> static_analysis </a>条款的要求。请为此条款添加说明。
      edit_status: 编辑项目徽章状态
    form_basics:
      project_name:
        description: 项目的人类可读的名称是什么？
        details: 请注意，其他项目可能使用相同的名称。
        placeholder: FLOSS项目名称
      description:
        description: 什么是项目的简要描述？
        details: 包括关于项目的关键评论。使用Markdown语法。显示徽章时使用此信息。
        placeholder: 项目介绍
      homepage_url:
        description: 项目的URL（作为一个整体）是什么？
        placeholder: 项目网站网址
      repo_url:
        description: 版本控制存储库的URL是什么（它可能与项目URL相同）？
        placeholder: 项目仓库URL
      implementation_languages:
        description: 用什么编程语言实现项目？
        details: >-
          如果有多种语言，请将它们列为逗号分隔值（可选空格），并将它们从最多到最少使用。如果有长列表，请至少列出前三个最常见的列表。如果没有语言（例如，这是仅文档或仅测试项目），请使用单个字符“
          - ”。请使用每种语言的常规大小写，例如“JavaScript”。
        placeholder: 实现语言（逗号分隔列表格式），按使用量排序
      cpe:
        description_html: >-
          项目的<a href="https://nvd.nist.gov/cpe.cfm">通用平台枚举（CPE）</a>名称（如果有）？
        details_html: >-
          <a href="https://nvd.nist.gov/cpe.cfm">通用平台枚举（CPE）</a>是用于信息技术系统，软件和软件包的结构化命名方案。在报告漏洞时，它可用于多个系统和数据库。
        placeholder: "（可选）CPE名称"
      license:
        description_html: 项目使用什么许可证发布？
        details_html: >-
          请使用<a href="https://spdx.org/licenses/"> SPDX许可证表达格式</a>;例子包括“Apache-2.0”，“BSD-2-Clause”，“BSD-3-Clause”，“GPL-2.0+”，“LGPL-3.0
          +”，“MIT”和“(BSD-2-Clause OR Ruby)”。
        placeholder: FLOSS许可证
      additional_rights_changes:
        description: "（高级）哪些用户还有额外权限编辑此徽章条目？目前：%{current_rights}"
        details_html: >-
          大多数项目应忽略此字段。项目徽章条目可以由徽章条目所有者（创建者），BadgeApp管理员以及任何可以提交给GitHub存储库（如果在GitHub上）的人员进行编辑。如果您希望其他人能够编辑此徽章条目，并且您已具有此项目徽章条目的编辑权限，则可以为其他用户提供编辑权限。只需输入“+”，后跟一个逗号分隔的整数用户ID列表。那么这些用户也将被允许编辑此项目条目。如果您是徽章条目的所有者或BadgeApp管理员，则可以通过输入“
          - ”，后跟逗号分隔的整数用户ID列表，从该列表中删除用户。如果多个用户尝试同时编辑，此应用程序使用乐观锁定机制来防止保存过期数据。只有此项目条目的所有者和BadgeApp管理员才能更改此字段。
        placeholder: 更改使用+或 - 后跟逗号分隔的用户标识列表
    form_early:
      badge_intro:
        description: 遵循以下最佳实践的项目将能够自愿的自我认证，并显示他们已经实现了核心基础设施计划（CII）徽章。
        details_html: >-
          没有一套可以保证软件永远不会有缺陷或漏洞的做法；如果规范或假设是错误的，即使合适的方法也可能失败。也没有哪些做法可以保证一个项目能够维持健康和运作良好的开发者社区。但是，遵循最佳做法可以帮助改善项目的成果。例如，一些做法可以在发布之前进行多人评估，这可以帮助您找到其他难以找到的技术漏洞，并帮助建立信任，并希望不同公司的开发人员之间进行重复的交互。要获得徽章，必须满足所有“必须”和“禁止”的条款，满足所有“应该”条款或有合适的理由，<em>和</em>所有“建议”条款必须满足或未满足（至少希望考虑）。欢迎通过<a
          href="https://github.com/coreinfrastructure/best-practices-badge">
          GitHub网站创建问题或提出请求</a>进行反馈。另外还有一个<a href ="https://lists.coreinfrastructure.org/mailman/listinfo/cii-badges">一般讨论邮件列表</a>。<br/>
          <br/>
      got_badge:
        description_1: 如果这是您的项目，请在您的项目页面上显示您的徽章状态！徽章状态如下所示：
        description_2: 这里是如何嵌入它：
        details_html: >-
          您可以通过将其嵌入在您的Markdown文件中：<br/> %{markdown_embedding}
          <br/>或将其嵌入到HTML中来显示您的徽章状态：<br/> %{html_embedding} <br/>
        editing_description_html: >-
          <strong>请经常提交</strong>保存您的工作（您可以随时返回并编辑更多内容）。 <br> <br>如果您需要帮助，有疑问或发现问题，请<em><a
          href="mailto:&#99;ii&#45;badges&#45;questions&#45;own&#101;r&#64;lists&#46;coreinfrastructure&#46;or&#103;">发送邮件</a>
          </em>或者 <em><a href="https://github.com/coreinfrastructure/best-practices-badge/issues"
          target="_blank">提交问题</a></em>。
        badge_alt: 项目%{id}的徽章级别为%{level}
      level:
        0_html: 这些是%{passing}级别条款。您还可以查看%{silver}或%{gold}级别条款。
        1_html: 这些是%{silver}级别条款。您还可以查看%{passing}或%{gold}级别条款。
        2_html: 这些是%{gold}级别条款。您还可以查看%{passing}或%{silver}级别条款。
        '0': 通过
        '1': 白银
        '2': 黄金
    misc:
      disabled_reminders: "（高级）禁用不活动提醒（我们建议您取消选中此选项）"
      general_comments:
        description: 关于该项目的其他一般性意见：
        placeholder: 附加评论（MarkDown格式）
      some_not_crypto_html: 请注意，某些软件不需要使用加密机制。
      dont_use_crypto: 如果项目生成的软件不使用加密机制，请按这里
      future_header_html: >-
        这些是我们打算在不久的将来添加的条款，但徽章认证目前<em>不需要</em>。这个宽限期允许项目更新到更改的标准，并保留他们的徽章作为提升的最佳实践。
      in_javascript:
        collapse_all_title: 折叠所有面板
        collapse_all: 折叠面板
        expand_all_title: 展开所有面板
        expand_all: 展开面板
        show_details: 显示详细资料
        hide_details: 隐藏细节
        show_all_details: 显示所有细节
        hide_all_details: 隐藏所有细节
        show_met_title: 显示满足和N/A的条款
        show_met_html: 显示满足＆amp; N/A
        hide_met_title: 隐藏满足和N/A条款（留下不满足和未知）
        hide_met_html: 隐藏满足 &amp; N/A
        passing_alt: 足够获得徽章！
        barely_alt: 勉强够获得徽章。
        failing_alt: 不足以获得徽章。
        unknown_alt: 未知的所需信息，不足以用于徽章。
        met_url_placeholder: "（需要URL）请说明如何满足，包括1+ 关键URL。"
        met_justification_placeholder: "（必填）请说明如何满足这一点，可能包括1+
          关键URL。"
        met_placeholder: "（可选）请解释如何满足这一点，可能包括1+ 关键URL。"
        unmet_placeholder: 请说明为什么不满足是合理的，包括1+关键网址。
        na_justification_placeholder: "（必填）请说明为什么不适用（N/A），可能包括1+关键网址。"
        na_placeholder: "（可选）请说明为什么不适用（N/A），可能包括1+关键网址。"
        unknown_placeholder: 请解释
      toggle_details_title: 切换细节文字
      details: 详细信息
      url_required: 需要网址
      future_criterion: 未来条款
      url_required_warning: 警告：需要URL，但找不到URL。
      justification_required_warning: 警告：需要更长的理由。
    delete:
      done: 项目已成功删除。
  user_mailer:
    account_activation:
      before_html: |-
        <h1>CII 最佳实践徽章计划</h1>
        <p>您好！</p>
        <p>
        欢迎来到徽章计划！
        点击下面的链接激活帐户：
        </p>
      before_text: |
        您好！
        欢迎来到CII 最佳实践徽章计划！
        点击下面的链接激活帐户：
      activate: 启用
      subject: 帐号激活
    github_welcome:
      before_html: |-
        <p>您好，</p>
        <p>
        感谢连接到您的GitHub账户，欢迎来到
        CII最佳实践徽章计划！
        </p>
        <p>
        如果该操作不是由您本人做出，请检查您的 GitHub
        安全日志：Settings&gt;Security.
        </p>
      before_text: |-
        您好，
        感谢连接到您的GitHub账户，欢迎来到
        CII最佳实践徽章计划！
        如果该操作不是由您本人做出，请检查您的 GitHub
        安全日志：Settings>Security。
      subject: 欢迎来到徽章计划
    password_reset:
      before_html: |-
        <h1>重设密码</h1>
        <p>要重设密码，请点击下面的链接：</p>
      before_text: 要重设密码，请点击下面的链接：
      after_html: |
        <p>此链接将在两个小时后过期。</p>
        <p>
        如果您没有要求重置密码，
        请忽略此电子邮件，
        您的密码将保持原样。
        </p>
      after_text: |
        此链接将在两个小时后过期。
        如果您没有要求重置密码，
        请忽略此电子邮件，
        您的密码将保持原样。
      reset_password: 重设密码
      subject: 重设密码
    user_update:
      before_text: 您帐户的某些用户数据已更新。
      username_changed: 用户名已更改。
      email_changed: 电子邮件地址已更改。
      password_changed: 密码已更改。
      locale_changed: 区域设置已更改。
      current_state: 对于当前状态，请参阅：
      after_text: 如果有问题，请提醒我们。
      subject: 用户数据已编辑
  submit: 提交
  account_activations:
    activated: 帐户已激活！
    failed_activation: 激活链接无效
  password_resets:
    forgot_password: 忘记密码
    reset_password: 重设密码
    password_confirmation: 确认
    email_not_found: 电子邮件地址未找到
    password_empty: 密码不能为空
    password_reset: 密码已重置
    instructions_sent: 电子邮件发送密码重置说明
    cant_reset_nonlocal: 对不起，无法重设非本地用户的密码
    reset_expired: 密码重设已过期。
    update_password: 更新密码
  report_mailer:
    new_project_heading: 感谢您将项目添加到最佳实践徽章计划中
    new_project_part1: 感谢您将项目添加到最佳实践徽章计划中。项目的当前名称为：
    new_project_part2: 请访问您的徽章项，完成相关信息，以获取徽章！您的徽章项的网址为：
    new_project_part3_html: |-
      <p>
      我们鼓励持续性的进展。
      </p>
      <p>
      如果您想 <em>仅</em> 查看遗漏的信息，
      访问您的徽章项页面，
      点击接近上方的按钮：“隐藏已满足或不涉及的条款”。
      有问题，或者需要帮助，请联系：
      <a href="mailto:&#99;ii&#45;badges&#45;questions&#45;own&#101;r&#64;lists&#46;coreinfrastructure&#46;or&#103;">&#99;ii&#45;badges&#45;questions&#45;own&#101;r&#64;lists&#46;coreinfrastructure&#46;or&#103;</a>
      或者提交问题：
      <a href="https://github.com/coreinfrastructure/best-practices-badge/issues">https://github.com/coreinfrastructure/best-practices-badge/issues</a>
      （点击“new issue”）。
      </p>
      <p>
      感谢您的时间投入。
      </p>
    new_project_part3_text: |
      我们鼓励持续性的进展。
      如果您想仅查看遗漏的信息，
      访问您的徽章项页面，
      点击接近上方的按钮：“隐藏已满足或不涉及的条款”。
      有问题，或者需要帮助，请联系：
      cii-badges-questions-owner@lists.coreinfrastructure.org
      或者提交问题：
      https://github.com/coreinfrastructure/best-practices-badge/issues
      （点击“new issue”）。
      感谢您的时间投入。
    in_markdown_add: 在markdown标记文本中，您可以添加：
    in_html_add: 在HTML中，您可以添加：
    ending: "--- David A. Wheeler，CII最佳实践徽章技术负责人"
    subject_achieved_passing: 恭喜获得新的%{new_level}最佳实践徽章！
    subject_no_longer_passing: 您的最佳实践徽章不再是%{old_level}
    subject_new_project: 您已将项目添加到CII最佳实践徽章计划
    subject_reminder: 您的项目还没有“最佳实践”徽章
    subject_project_deleted: 名为%{project_name}的项目%{project_id}已被删除
    gained_level_part1: |
      恭喜！
      根据您提供的信息，
      您的项目获得了CII最佳实践“%{new_level}”徽章。
      有关详细信息，请参阅此URL：
    gained_level_part2: |-
      请将您的徽章添加到您的项目和/或代码仓库网站；
      这是您应得的：
    gained_level_part3: |
      我们强烈建议您添加或改进理由陈述，
      包括添加指向更多信息的URL。
      如果您有关于如何改进条款或徽章网络应用程序的建议，请提出问题：
      https://github.com/coreinfrastructure/best-practices-badge/issues
      如果您对项目进行了更改以获得徽章，请通过电子邮件通知我们：cii-badges-questions@lists.coreinfrastructure.org。
      我们的目标之一是鼓励项目进行持续性的改进。
      我们把这些报告放在公共维基上；
      如果您不想公开发布更改，请告诉我们：
      https://github.com/coreinfrastructure/best-practices-badge/wiki/Impacts
      谢谢。恭喜！
    lost_level_message: |-
      很抱歉，您的项目不再具有“%{old_level}”徽章
      现在是“%{new_level}”。
      有关详细信息，请参阅以下URL：
    reminder_body_html: |-
      <h1>%{project_name} 最佳实践徽章自动邮件提醒</h1>
      <p>
      这是一个自动提醒，您的项目
      "%{project_name}"
      当前并没有“最佳实践”徽章，
      并且徽章记录有一段时间未更新。
      </p>
      <p>
      您的徽章记录在
      <a href="%{project_info_url}">%{project_info_url}</a>
      最后更新于 %{project_updated_at}。
      当前完成度 %{project_badge_percentage_0}% (总计 100%)。
      </p>
      <p>
      我们鼓励持续性的进展。
      请访问您的徽章记录：
      <a href="%{project_info_url}">%{project_info_url}</a>
      以补充信息并获得徽章！
      </p>
      <p>
      如果您想<em>仅查阅</em>当前不满足的情况，可访问您的徽章记录，
      选择靠近上方的“展开所有面板”，并
      选择“隐藏满足和N/A条款”。
      如果您有疑问，或者需要帮助，请联系
      <a href="mailto:&#99;ii&#45;badges&#45;questions&#45;own&#101;r&#64;lists&#46;coreinfrastructure&#46;or&#103;">&#99;ii&#45;badges&#45;questions&#45;own&#101;r&#64;lists&#46;coreinfrastructure&#46;or&#103;</a>
      或者在该链接创建问题：
      <a href="https://github.com/coreinfrastructure/best-practices-badge/issues">https://github.com/coreinfrastructure/best-practices-badge/issues</a>
      (点击 "new issue")。
      </p>
      <p>
      如果您持续的更新徽章记录，我们将不会发送提醒邮件，
      并且我们估计30~60天才会发送一次。当然，
      如果您想完全禁用提醒邮件，请访问您的徽章记录：
      <a href="%{project_info_url}">%{project_info_url}</a>
      并且启用“禁用不活动提醒”。
      我们希望您继续努力
      并最终获得徽章。
      </p>
      <p>
      感谢您的时间。
      </p>
    reminder_body_text: |-
      这是一个自动提醒，您的项目
      "%{project_name}"
      当前并没有“最佳实践”徽章，
      并且徽章记录有一段时间未更新。
      您的徽章记录在
      %{project_info_url}
      最后更新于 %{project_updated_at}
      当前完成度 %{project_badge_percentage_0}% (总计 100%).
      我们鼓励持续性的进展。
      请访问您的徽章记录：
      %{project_info_url}
      以补充信息并获得徽章！
      如果您想仅查阅当前不满足的情况，可访问您的徽章记录，
      选择靠近上方的“展开所有面板”，并
      选择“隐藏满足和N/A条款”。
      如果您有疑问，或者需要帮助，请联系
      cii-badges-questions-owner@lists.coreinfrastructure.org
      或者在该链接创建问题：
      https://github.com/coreinfrastructure/best-practices-badge/issues
      (点击 "new issue").
      如果您持续的更新徽章记录，我们将不会发送提醒邮件，
      并且我们估计30~60天才会发送一次。当然，
      如果您想完全禁用提醒邮件，请访问您的徽章记录：
      %{project_info_url}
      并且启用“禁用不活动提醒”。
      我们希望您继续努力
      并最终获得徽章。
      感谢您的时间。
  project_name_unknown: "(未知名称)"
  locale_name:
    en: 英文 / English (en）
    fr: 法语 / Français (fr)
    zh-CN: 中文（简体）/简体中文（zh-CN）
    de: 德文 / Deutsch (de)
    ja: 日语 / 日本語 (ja)
    ru: 俄语 / Русский (ru)
  criteria:
    '0':
      description_good:
        description: 项目网站必须简明扼要地描述软件的作用（它解决了什么问题？）。
        details: 必须采用潜在用户可以理解的语言（例如，它使用最少的术语/行话）。
        met_placeholder: "（可选）简洁描述在哪里？考虑提供一个URL。"
      interact:
        description: 项目网站必须提供有关如何获取和提供反馈（错误报告或增强功能）以及如何贡献的信息。
        met_placeholder: "（可选）此信息在哪里？考虑提供URL。"
      contribution:
        description: 关于如何贡献的信息必须解释贡献流程（例如，是否使用拉请求？）
        details: >-
          除非另有说明，否则我们假定<a href="https://guides.github.com/activities/contributing-to-open-source/">
          GitHub上的项目使用问题列表（Issues）和拉（Pull）请求</a>。这些信息可以简短，例如，说明项目使用拉请求，问题跟踪器或邮寄到邮件列表中的哪一个。
        met_placeholder: "（需要URL）流程是什么？在哪个URL有说明？"
      contribution_requirements:
        description: 关于如何贡献的信息应包括对可接受的贡献的要求（例如，引用任何所需的编码标准）。
        unmet_placeholder: 为什么需求很明显，不需要这些信息？
      floss_license:
        description: 项目生产的软件必须作为FLOSS发布。
        details: >-
          FLOSS是以符合<a href="https://opensource.org/osd-annotated">开源定义</a>或<a
          href ="http://www.gnu.org/philosophy/free-sw.en.html">免费软件定义</a>。此类许可证的示例包括<a
          href="http://creativecommons.org/publicdomain/zero/1.0/">
          CC0 </a>，<a href ="https://opensource.org/licenses/MIT">
          MIT </a>，<a href="https://opensource.org/licenses/BSD-2-Clause">
          BSD 2条款</a>，<a href ="https://opensource.org/licenses/BSD-3-Clause">
          BSD 3条款修订版</a>，<a href="https://opensource.org/licenses/Apache-2.0">
          Apache 2.0 </a>，<a href ="https://opensource.org/licenses/lgpl-license">
          Lesser GNU通用公共许可证（LGPL）</a>，以及<a href ="https://opensource.org/licenses/gpl-license">
          GNU通用公共许可证（GPL）</a>。为了我们的目的，这意味着许可证必须是：<ul> <li> <a
          href="https://opensource.org/licenses">开放源码促进会（OSI）批准的许可证</a>，或</li>
          <li> <a href="https://www.gnu.org/licenses/license-list.html">自由软件基金会（FSF）批准的免费许可证</a>，或</li>
          <li> <a href="https://www.debian.org/legal/licenses/">
          Debian 主流可接受的免费许可</a>，或</li> <li><a href="https://fedoraproject.org/wiki/Licensing:Main?rd=Licensing">a
          "good" license according to Fedora</a>。</li> </ul>该软件也可以用其他许可证（例如，“GPLv2或专有”是可以接受的）。
      floss_license_osi:
        description: >-
          建议由项目生成的软件的任何必需的许可证是由<a href="https://opensource.org/licenses">开放源码促进会（OSI）批准的许可证（英文）</a>。
        details: OSI （开放源代码促进会）使用严格的审批流程来确定哪些许可证是开源软件（OSS）。
      license_location:
        description: 项目必须将其许可证在其源代码存储库中的标准位置发布。
        details: 例如，作为名为LICENSE或COPYING的顶级文件。许可证文件名之后可以是扩展名，例如“.txt”或“.md”。
      documentation_basics:
        description: 项目必须为项目生成的软件提供基本文档。
        details: >-
          该文档必须在某些媒体（例如文本或视频）中，包括：如何安装它，如何启动它，如何使用它（可能使用教程使用示例）以及如何安全地使用它（例如，做什么和不做什么），如果这是软件的一个适当的话题。安全文档不需要太长篇幅。项目可以使用非项目内容的超文本链接作为文档。如果项目不生产软件，请选择“不适用”（N/A）。
        met_placeholder: "（可选）哪些URL是文档的入口点？"
      documentation_interface:
        description: 项目必须提供描述项目生成的软件的外部接口（输入和输出）的参考文档。
        details: >-
          外部接口的文档向最终用户或开发人员解释如何使用它。这将包括其应用程序接口（API），如果软件有。如果它是一个库，记录可以调用的主要类/类型和方法/函数。如果是Web应用程序，定义其URL接口（通常是其REST接口）。如果是命令行界面，请记录其支持的参数和选项。在许多情况下，最好是自动生成大部分文档，以便本文档随着软件的更改而保持同步，但这并不是必需的。项目可以使用非项目材料的超文本链接作为文档。文档可以自动生成（实际上这通常是最好的方法）。可以使用Swagger
          / OpenAPI生成REST接口的文档。代码界面文档可以使用<a href="http://usejsdoc.org/">
          JSDoc </a>（JavaScript），<a href="https://esdoc.org/">
          ESDoc </a>（JavaScript），pydoc（Python）和Doxygen（很多）。仅在实现代码中添加注释不足以满足本条款；在没有阅读所有源代码的情况下，需要一个简单的方法来查看信息。如果项目不生产软件，请选择“不适用”（N/A）。
      sites_https:
        description: 项目网站（网站，存储库和下载URL）必须使用TLS支持HTTPS。
        details: >-
          您可以从<a href="https://letsencrypt.org/">Let's Encrypt</a>获取免费证书。项目可以使用（例如）<a
          href="https://help.github.com/articles/securing-your-github-pages-site-with-https/">
          GitHub页面</a>实现此条款， <a href="https://about.gitlab.com/2016/12/24/were-bringing-gitlab-pages-to-community-edition/">GitLab页面</a>，或<a
          href ="https://sourceforge.net/blog/introducing-https-for-project-websites/">
          SourceForge项目页面</a>。如果您使用具有自定义域的GitHub页面，则可以使用内容传送网络（CDN）作为代理来支持HTTPS，例如<a
          href ="https://blog.cloudflare.com/secure-and -fast-github-pages-with-cloudflare/">博客文章“使用CloudFlare安全加速GitHub页面”</a>，以满足此条款。如果您支持HTTP，我们敦促您将HTTP流量重定向到HTTPS。
      discussion:
        description: >-
          该项目必须有一个或多个讨论机制（包括建议的更改和问题），可搜索，允许通过URL访问消息和主题，使新人能够参与一些讨论，并且不需要客户端安装专有软件。
        details: >-
          可接受机制的示例包括归档邮件列表，GitHub问题和拉请求讨论，Bugzilla，Mantis和Trac。如果满足这些标准，异步讨论机制（如IRC）是可以接受的；确保有一个URL可访问归档机制。允许专有JavaScript，但不鼓励。
      english:
        description: 项目应该提供英文文档，并能够接受英文的代码的错误报告和评论。
        details: >-
          英语是计算机技术的<a href="https://en.wikipedia.org/wiki/Lingua_franca">通用语言</a>；支持英语增加了全球不同潜在开发者和检视者的数量。即使核心开发人员的主要语言不是英文，项目也可以达到这个标准。
      repo_public:
        description: 该项目必须有一个版本控制的源代码存储库。它必须是公开可读的并可通过URL访问。
        details: >-
          该URL可以与项目URL相同。该项目可能在特定情况下使用私人（非公开）分支，而更改不会公开发布（例如，在向公众披露漏洞之前修复漏洞）。
      repo_track:
        description: 项目的源代码存储库必须跟踪所做的更改，谁进行了更改，何时进行了更改。
      repo_interim:
        description: 为了实现协作检视，项目的源代码存储库必须包括临时版本，以便检视版本之间的变化；它不得仅包括最终版本。
        details: >-
          项目可以选择从其公共源代码库中删除特定的临时版本（例如，修复特定的未公开安全漏洞，可能永远不会公开发布的内容，或者包括不能合法发布而且不是最终版本的内容）。
      repo_distributed:
        description: 建议使用通用分布式版本控制软件（例如，git）作为项目的源代码存储库。
        details: Git不是必须，项目在合适场景可以使用集中版本控制软件（如subversion）。
      version_unique:
        description: 项目生成的用于每个用户使用的版本必须具有唯一版本标识符。
        details: >-
          本条款可以通过各种方式来满足，包括提交ID（例如git提交ID或者Mercurial 更改列表id）或版本号（包括使用语义版本或基于日期的方案，如YYYYMMDD的版本号）。
      version_semver:
        description: 建议使用<a href="http://semver.org">语义版本控制（SemVer）格式</a>进行发布。
        details: >-
          其他版本编号方案，如提交ID（例如git commit id或mercurial changeset id）或基于日期的方案，如YYYYMMDD，可以用作版本号，因为它们是唯一的。一些备选方案可能会导致问题，因为用户可能无法轻松确定是否是最新的。如果所有目标客户仅运行最新版本，则SemVer可能不太有助于识别软件版本（例如，它是通过持续交付不断更新的单个网站或互联网服务的代码）。
      version_tags:
        description: 建议项目识别其版本控制系统中的每个版本。例如，建议使用git的项目，使用git标签识别每个版本。
      release_notes:
        description: >-
          该项目必须在每个版本中提供发布说明，这是该版本中主要变化的可读的摘要，以帮助用户确定是否应升级，升级影响将如何。发行说明不能是版本控制日志的原始输出（例如，“git
          log”命令结果不是发行说明）。其产出不适用于多个地点的项目（如单个网站或服务的软件），并采用持续交付，可以选择“N/A”。
        details: >-
          发行说明可以以各种方式实施。许多项目将它们添加到名为“NEWS”，“CHANGELOG”或“ChangeLog”的文件中，可选的包含“.txt”，“.md”或“.html”等扩展名。历史上，术语“更改日志”是指<em>每个</em>更改的日志，但为了满足这些条款，需要的是可读取的摘要。发行说明可以由版本控制系统机制提供，例如<a
          href="https://github.com/blog/1547-release-your-software">
          GitHub发布工作流程</a>。
      release_notes_vulns:
        description: 发行说明必须列出每个新版本中修复的每个公开的漏洞。如果没有发行说明或者没有公开的漏洞，选择“不适用”。
      report_process:
        description: 项目必须为用户提交错误报告（例如，使用问题跟踪器或邮件列表）提供相关流程。
      report_tracker:
        description: 项目必须使用问题跟踪器来跟踪每个问题。
        unmet_placeholder: 为什么没有问题跟踪器？
      report_responses:
        description: 该项目必须响应过去2-12个月内（含）提交的大多数错误报告；响应不需要包括修复。
      enhancement_responses:
        description: 该项目应该对过去2-12个月内（包括）的大部分（> 50％）的增强请求作出回应。
        details: >-
          答复可能是“不”或有关其价值的讨论。目的只是对某些请求有一些回应，这表明项目还活着。为了该条款的目的，项目不需要计数无效请求（例如，来自垃圾邮件发送者或自动系统）。如果项目不再进行增强，请选择“未满足”，并将介绍此情况的URL包含在内。如果一个项目有超出处理能力的增强需求数量，请选择“未满足”并解释。
      report_archive:
        description: 该项目必须有一个公开的报告和回复的档案供后续搜索。
      vulnerability_report_process:
        description: 项目必须在项目网站上发布报告漏洞的流程。
        details: >-
          例如，https://PROJECTSITE/security 上的一个明确指定的邮箱地址，通常以 security@example.org
          的形式。这可能与其错误报告流程相同。漏洞报告可能一直是公开的，但是许多项目都有一个私密漏洞报告机制。
      vulnerability_report_private:
        description: 如果支持私有漏洞报告，项目必须包括如何以保密的方式发送信息。
        details: >-
          示例包括使用HTTPS（TLS）或使用OpenPGP加密的电子邮件在网络上提交的私密缺陷报告。如果漏洞报告总是公开的（从来没有私密漏洞报告），请选择“不适用”（N/A）。
      vulnerability_report_response:
        description: 该项目在过去6个月收到的任何漏洞报告的初始响应时间必须小于或等于14天。
        details: 如果过去6个月没有报告漏洞，请选择“不适用”（N/A）。
      build:
        description: 如果项目生成的软件需要构建使用，项目必须提供可以从源代码自动重新构建软件的可工作的构建系统。
        details: >-
          构建系统确定重建软件（以及以什么顺序）需要执行哪些操作，然后执行这些步骤。例如，它可以调用编译器来编译源代码。如果从源代码创建可执行文件，则必须可以修改项目的源代码，然后通过这些修改生成更新的可执行文件。如果项目生成的软件取决于外部库，则构建系统<em>不必</em>构建那些外部库。如果在修改源代码之后不需要构建任何使用该软件的软件，请选择“不适用”（N/A）。
      build_common_tools:
        description: 建议使用通用工具来构建软件。
        details: 例如，Maven，Ant，cmake，autotools，make或rake。
      build_floss_tools:
        description: 该项目应该仅使用FLOSS工具来构建。
      test:
        description: 该项目必须使用至少一个作为FLOSS公开发布的自动测试套件（该测试套件可以作为单独的FLOSS项目维护）。
        details: 该项目可以使用多个自动测试套件（例如，一个是快速运行的测试套件，而另一个更为彻底但需要特殊设备）。
      test_invocation:
        description: 测试套件应该以该语言的标准方式进行调用。
        details: 例如“make check”，“mvn test”或“rake test”。
      test_most:
        description: 建议测试套件覆盖大部分（或理想情况下所有）代码分支，输入字段和功能。
      test_continuous_integration:
        description: 建议项目实施持续集成，将新的或更改的代码经常集成到中央代码库中，并对结果进行自动化测试。
      test_policy:
        description: 该项目必须有通用的策略（正式或非正式），当主要的新功能被添加到项目生成的软件中，该功能的测试应该同时添加到自动测试套件。
        details: 只要有相应的策略，即使是通过口头传播，也就是说开发人员应该为主要的新功能在自动化测试套件中添加测试，选择“Met”。
      tests_are_added:
        description: >-
          该项目必须有证据表明，在项目生成的软件的最近重大变化中，已经遵守了添加测试的条款：<a href="#test_policy">
          test_policy </a>。
        details: >-
          主要功能通常在发行说明中提及。不需要完美，只需证明，当新的主要功能添加到项目生成的软件时，测试通常会在实践中被添加到自动化测试套件中。
      tests_documented_added:
        description: >-
          建议您在更改提案的说明<em>文档</em>中添加测试策略要求（请参阅<a href="#test_policy">test_policy</a>）。
        details: 但是，只要在实践中添加了测试，即使是非正式规则也是可以接受的。
      warnings:
        description: >-
          该项目必须启用一个或多个编译器警告标志，“安全”语言模式，或者使用单独的“linter”工具查找代码质量错误或常见的简单错误，如果至少有一个FLOSS工具可以在所选择的语言实现此条款。
        details: >-
          编译器警告标志的例子包括gcc/clang “-Wall”。 “安全”语言模式的示例包括JavaScript
          “use strict”和perl5的“使用警告”。一个单独的“linter”工具用于检查源代码以查找代码质量错误或常见的简单错误。这些通常在源代码或构建指令中启用。
      warnings_fixed:
        description: 该项目必须处理警告。
        details: >-
          告警是通过执行<a href="#warnings">warnings</a>条款确定的。该项目应该修复告警或在源代码中将其标记为误报。理想情况下，不会有告警，但项目可能会接受一些告警（通常每100行小于1个告警，或整体少于10个告警）。
      warnings_strict:
        description: 建议在实际情况下，项目以最严格方式对待项目生成的软件中的告警。
        details: 某些项目无法有效启用某些警告。需要证明的是，项目正在努力的启用警告标志，以便早期发现错误。
      know_secure_design:
        description: 该项目必须至少有一个主要开发人员知道如何设计安全软件。
        details: >-
          这需要了解以下设计原则，包括<a href="http://web.mit.edu/Saltzer/www/publications/protection/">
          Saltzer和Schroeder </a>中的8项原则：<ul> <li>机制经济（保持设计简单实用，例如采用彻底简化）<li>故障安全默认（默认情况下，访问决策应拒绝），项目安装应默认安全）<li
          >完全仲裁（必须检查每个可能被限制的访问权限，并且不可绕过）<li>开放式设计（安全机制不应该依赖于攻击者对其设计的无知，而应该更容易地保护和更改信息，例如密钥和密码）<li>特权分离（理想情况下，对重要对象的访问应该取决于多个条件，从而破坏一个保护系统将无法实现完全访问。如，多因子身份验证，要求密码和硬件令牌，比单因子认证安全性更高）<li>最小权限（进程应该以最少的权限运行）<li>最少的公共机制（设计应该最大限度地减少所有用户所依赖的，涉及到多个用户的共同机制，如，临时文件的目录）<li>心理可接受性（人机接口必须设计为易于使用
          —— 设计为“最不惊讶”）<li>有限的攻击面（攻击面 —— 一组不同的入口，其​​中攻击者可以尝试输入或提取数据
          —— 应该受到限制）<li>输入验证与白名单（输入通常应该在被接受之前检查以确定是否有效；此验证应使用白名单（仅接受已知的有效值），而不是黑名单（尝试列出已知的非法值））。
          </ul>项目中的“主要开发人员”的定义是熟悉项目代码的任何人，很乐意对其进行更改，并被项目中大多数其他参与者确认。主要开发人员通常会在过去一年中通过代码，文档或回答问题提供一些贡献。开发人员通常被认为是主要开发人员，如果他们启动项目（并且还没有离开项目满三年），可以选择在私人漏洞报告渠道（如果有的话）上接收信息，可以代表项目接受提交，或执行项目软件的最终版本发布。如果只有一个开发者，那个人是主要开发人员。
      know_common_errors:
        description: 该项目的主要开发人员中，至少有一个必须知道导致这类型软件漏洞的常见错误类型，以及至少有一种方法来对付或缓解这些漏洞。
        details: >-
          示例（取决于软件的类型）包括SQL注入，操作系统注入，经典缓冲区溢出，跨站点脚本（XSS），缺少认证和缺少授权。请参阅<a
          href="http://cwe.mitre.org/top25/"> CWE/SANS 25种最常见漏洞</a>或<a
          href ="https://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project">
          OWASP十大漏洞类型项目</a>。
      crypto_published:
        description: 项目生成的软件默认情况下，只能使用由专家公开发布和审查的加密协议和算法（如果使用加密协议和算法）。
        details: 这些加密条款并不总是适用，因为某些软件不需要直接使用加密功能。
      crypto_call:
        description: >-
          如果项目生成的软件是应用程序或库，其主要目的不是实现加密，那么它应该只调用专门设计实现加密功能的软件，而不应该重新实现自己的。
      crypto_floss:
        description: 项目所产生的软件中，所有依赖于密码学的功能必须使用FLOSS实现。
        details: >-
          请参阅<a href="https://opensource.org/osr">OSI （开放源代码促进会）发布的软件开放标准需求</a>。
      crypto_keylength:
        description: >-
          项目生成的软件中的安全机制使用的默认密钥长度必须至少达到2030年（如2012年所述）的NIST最低要求。必须提供配置，以使较小的密钥长度被完全禁用。
        details: >-
          这些最小位长度是：对称密钥112，因式分解模数2048，离散对数密钥224，离散对数组2048，椭圆曲线224和散列224（密码散列不涉及该位长度），关于密码散列的更多信息可以在<a
          href="#crypto_password_storage"> crypto_password_storage
          </a> 条款）。请参阅<a href="http://www.keylength.com"> http://www.keylength.com
          </a>以比较不同组织的密钥长度建议。在某些配置中，软件可能允许较小的密钥长度（理想情况下不会，因为这允许降级攻击，但是互操作性有时需要较短的密钥长度）。
      crypto_working:
        description: >-
          项目产生的软件中的默认安全机制不得取决于已被破解的密码算法（例如，MD4，MD5，单DES，RC4，Dual_EC_DRBG）或使用不适合上下文的密码模式（例如，ECB模式几乎不适当，因为它揭示了密文中相同的块，如<a
          href="https://blog.filippo.io/the-ecb-penguin/"> ECB企鹅</a>所示。CTR模式通常是不合适的，因为如果重复输入状态，则它不执行认证并导致重复）。
        details: >-
          在许多情况下，最好选择设计用于组合保密和认证的块密码算法模式，例如Galois / Counter Mode（GCM）和EAX。项目可以允许用户为必要的兼容性启用已被破解的加密机制，但是需要用户知道他们正在这么做。
      crypto_weaknesses:
        description: >-
          由项目产生的软件中的默认安全机制不应该依赖于具有已知严重弱点的加密算法或模式（例如，SHA-1密码散列算法或SSH中的CBC模式）。
        details: >-
          在<a href="https://www.kb.cert.org/vuls/id/958563"> CERT：SSH
          CBC漏洞</a>中讨论了SSH中CBC模式的问题。
      crypto_pfs:
        description: >-
          项目产生的软件中的安全机制应该​​对密钥协商协议实施完美的前向保密（PFS），如果长期密钥集合中的一个长期密钥在将来泄露，也不能破坏从一组长期密钥导出的会话密钥。
      crypto_password_storage:
        description: >-
          如果项目产生的软件存储用于外部用户认证的密码，则必须使用密钥拉伸（迭代）算法（例如，PBKDF2，Bcrypt或Scrypt）将密码存储为每用户盐值不同的迭代散列
          。
        details: >-
          此条款仅适用于软件强制使用密码验证用户身份的情况（如服务器端Web应用程序）。在软件存储用于认证到其他系统的密码（例如，该软件实现某个其他系统的客户端）的情况下，这是不适用的，因为该软件的至少某个部分必须经常访问未散列加密的密码。
      crypto_random:
        description: 由项目生成的软件中的安全机制必须使用密码学安全的随机数生成器生成所有加密密钥和随机数，并且不得使用密码学不安全的生成器。
        details: >-
          密码安全的随机数生成器可以是硬件随机数生成器，或者它可以是使用诸如Hash_DRBG，HMAC_DRBG，CTR_DRBG，Yarrow或Fortuna之类的算法的加密安全的伪随机数生成器（CSPRNG）。对<em>安全性</em>随机数生成器的调用示例包括Java的java.security.SecureRandom和JavaScript的window.crypto.getRandomValues。调用<em>不安全</em>随机数生成器的示例包括Java的java.util.Random和JavaScript的Math.random。
      delivery_mitm:
        description: 该项目必须使用一种针对MITM攻击的传递机制。使用https或ssh + scp是可以接受的。
        details: >-
          一个更强大的机制是使用数字签名的软件包发布软件，因为这样可以减轻对分发系统的攻击，但只有在用户确信签名的公钥是否正确的情况下才可以确定。用户实际上会检查签名。
      delivery_unsigned:
        description: 不得通过http协议获取加密散列（例如，sha1sum）并直接使用，而不检查密码学签名。
        details: 这些散列可以在传输过程中修改。
      vulnerabilities_fixed_60_days:
        description: 被公开了超过60天的中等或更高严重程度的漏洞，必须被修复。
        details: >-
          该漏洞必须由项目本身修补和发布（修补程序可能在其他地方开发）。一旦漏洞具有公开发布的非付费信息的CVE（例如，在<a
          href="https://nvd.nist.gov/">国家漏洞数据库</a>）或项目已被通知，且信息已经发布给公众（可能是项目自己发布），则视为漏洞已经公众所知。如果其<a
          href="https://nvd.nist.gov/cvss.cfm"> CVSS 2.0 </a>基本分数为4或更高，则漏洞是中等到高的严重性。
          <strong>注意</strong>：这意味着全世界的所有攻击者可能会对用户造成长达60天的伤害。这个标准通常比Google在<a
          href="https://security.googleblog.com/2010/07/rebooting-responsible-disclosure-focus.html">重新启动负责任的披露</a>中所推荐的容易得多。因为Google建议，如果报告不是公开的，那么当项目得到通知，甚至报告<em>尚未公开</em>时，60天的时间段就会开始。
      vulnerabilities_critical_fixed:
        description: 项目在得到报告后应该迅速修复所有致命漏洞。
      no_leaked_credentials:
        description: 公共存储库不得泄漏旨在限制公众访问的有效私人凭证（例如，工作密码或私钥）。
        details: 项目可以泄漏测试和不重要数据库的“样本”凭据，只要它们不旨在限制公共访问。
      static_analysis:
        description: >-
          如果至少有一个FLOSS工具以所选择的语言实现此条款，则至少需要将一个静态代码分析工具应用于软件发布之前任何提议的主要生成版本。
        details: >-
          静态代码分析工具检查软件代码（源代码，中间代码或可执行文件），而不用特定输入执行。本条款中，编译器警告和“安全”语言模式不被视为静态代码分析工具（它们通常避免深入分析，因为速度至关重要）。此类静态代码分析工具的示例包括<a
          href="http://cppcheck.sourceforge.net/"> cppcheck </a>，<a
          href="http://clang-analyzer.llvm.org/"> clang静态分析器</a>，<a
          href="http://findbugs.sourceforge.net/"> FindBugs </a>（包括<a
          href =“https://h3xstream.github.io/find-sec-bugs/">FindSecurityBugs</a>），<a
          href="https://pmd.github.io/"> PMD </a>，<a href="http://brakemanscanner.org/">
          Brakeman </a>，<a href="https://scan.coverity.com/">
          Coverity质量分析器</a>和<a href ="http://www8.hp.com/au/en/software-solutions/static-code-analysis-sast/index.html">
          HP Fortify静态代码分析器</a>。更多的工具列表可以在诸如<a href="https://en.wikipedia.org/wiki/List_of_tools_for_static_code_analysis">维基百科静态代码分析工具列表</a>，<a
          href ="https://www.owasp.org/index.php/Static_Code_Analysis">关于静态代码分析的OWASP信息</a>，<a
          href ="http://samate.nist.gov/index.php/Source_Code_Security_Analyzers.html">
          NIST源代码安全分析器列表</a>和<a href="http://www.dwheeler.com/essays/static-analysis-tools.html">
          Wheeler的静态分析工具列表</a >。 <a href="https://continuousassurance.org/">
          SWAMP </a>是使用各种工具评估软件漏洞的免费平台。如果没有可用于所使用的实现语言的FLOSS静态分析工具，请选择“N/A”。
        na_placeholder: 为什么不能满足（例如，该语言没有FLOSS工具）？
        met_placeholder: 使用什么静态分析工具？
      static_analysis_common_vulnerabilities:
        description: 建议至少有一个用于static_analysis标准的静态分析工具包括在分析语言或环境中查找常见漏洞的规则或方法。
        details:
      static_analysis_fixed:
        description: 使用静态代码分析发现的所有中，高严重性可利用漏洞必须在确认后及时修复。
        details: >-
          如果其<a href="https://nvd.nist.gov/cvss.cfm"> CVSS 2.0
          </a>评分为4或更高，则此漏洞是中等到高的严重性。
      static_analysis_often:
        description: 建议每次提交或至少每天执行静态源代码分析。
      dynamic_analysis:
        description: 建议在发布之前，至少将一个动态分析工具应用于软件任何发布的主要生产版本。
        details: >-
          动态分析工具通过执行特定输入来检查软件。例如，项目可以使用模糊工具（例如，<a href="http://lcamtuf.coredump.cx/afl/">
          American Fuzzy Lop </a>）或Web应用扫描程序（例如，<a href ="https://www.owasp.org/index.php/OWASP_Zed_Attack_Proxy_Project">
          OWASP ZAP </a>或<a href="http://w3af.org/"> w3af </a>）。在某些情况下，<a
          href="https://github.com/google/oss-fuzz#introduction">
          OSS-Fuzz </a>项目可以对您的项目应用模糊测试。为满足此条款，动态分析工具需要以某种方式改变输入，以寻找各种问题，或者将其作为一个具有至少80％分支覆盖率的自动测试套件。
          <a href="https://en.wikipedia.org/wiki/Dynamic_program_analysis">动态分析维基百科页面</a>和<a
          href ="https://www.owasp.org/index.php/Fuzzing"> OWASP的fuzzing页面
          </a>识别一些动态分析工具。分析工具可能专注于寻找安全漏洞，但这不是必需的。
      dynamic_analysis_unsafe:
        description: >-
          建议如果项目生成的软件包含使用内存不安全语言编写的软件（例如C或C++），则至少有一个动态工具（例如，fuzzer或web应用扫描程序）与检测缓冲区覆盖等内存安全问题的机制例行应用。如果该项目生成的软件没有以内存不安全语言编写，请选择“不适用”（N
          / A）。
        details: >-
          检测内存安全问题的机制的示例包括<a href="https://github.com/google/sanitizers/wiki/AddressSanitizer">AddressSanitizer（ASAN）</a>（可在GCC和LLVM中使用），<a
          href ="http://clang.llvm.org/docs/MemorySanitizer.html">“Memory
          Sanitizer”</a>和<a href="http://valgrind.org/"> valgrind
          </a>。其他可能使用的工具包括<a href="http://clang.llvm.org/docs/ThreadSanitizer.html">ThreadSanitizer</a>和<a
          href ="http://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html">UndefinedBehaviorSanitizer</a>。广泛的断言也将起作用。
      dynamic_analysis_enable_assertions:
        description: 建议由项目生成的软件包括许多运行时断言，在动态分析期间检查。
      dynamic_analysis_fixed:
        description: 通过动态代码分析发现的所有严重性为中，高的可利用漏洞必须在确认后及时修复。
        details: >-
          如果<a href="https://nvd.nist.gov/cvss.cfm"> CVSS 2.0
          </a>基本分数为4，那么一个漏洞是中等到高的严重性。如果您没有运行动态代码分析，没有发现任何这样的漏洞，选择“不适用”（N/A）。
      installation_common:
        description: 该项目应该提供一种方法，使用常用惯例轻松安装和卸载项目生成的软件。
        details: >-
          示例包括使用软件包管理器（在系统或语言级别），“make install/uninstall”（支持DESTDIR），标准格式的容器或标准格式的虚拟机映像。安装和卸载过程（例如，打包）可以由第三方FLOSS软件实现。
      build_reproducible:
        description: >-
          建议该项目有一个<a href="https://reproducible-builds.org/">可重复构建</a>。如果没有发生构建（例如，直接使用源代码而不是编译的脚本语言），请选择“不适用”（N/A）。
        details: >-
          可复制的构建意味着多方可以独立地重做从源文件生成信息的过程，并获得每比特完全相同的结果。如果没有构建（例如，直接使用源代码而不是编译的脚本语言），请选择“N
          / A”。在某些情况下，这可以通过强制某种排序来解决。 JavaScript开发人员可能会考虑使用npm
          shrinkwrap和webpack的OccurenceOrderPlugin。 GCC和clang用户可能会发现-frandom-seed选项有用。通常可以通过指定可用于重新构建的特定容器或虚拟机的加密散列来为外部方定义构建环境（包括工具集）。
          <a href="https://reproducible-builds.org/docs/">可重复构建项目具有如何执行此操作的文档</a>。
      crypto_used_network:
        description: >-
          该项目产生的软件应该支持所有网络通信的安全协议，如SSHv2或更高版本，TLS1.2或更高版本（HTTPS），IPsec，SFTP和SNMPv3。默认情况下，FTP，HTTP，Telnet，SSLv3或更早版本和SSHv1等不安全协议将被禁用，只有在用户专门配置时才启用。如果项目生成的软件不支持网络通信，请选择“不适用”（N/A）。
      crypto_tls12:
        description: >-
          项目生成的软件（如果支持或使用TLS）应该至少支持TLS版本1.2。请注意，TLS的前身称为SSL。如果软件不使用TLS，请选择“不适用”（N/A）。
      crypto_certificate_verification:
        description: >-
          由项目生成的软件必须，如果它支持TLS，则在使用TLS（包括子资源）时默认执行TLS证书验证。如果软件不使用TLS，请选择“不适用”（N/A）。
        details: >-
          请注意，不正确的TLS证书验证是一个常见的错误。有关详细信息，请参阅<a href="http://crypto.stanford.edu/~dabo/pubs/abstracts/ssl-client-bugs.html">“世界上最危险的代码：在非浏览器软件中验证SSL证书“，Martin
          Georgiev等</a>和<a href="https://blogs.gnome.org/mcatanzaro/2016/03/12/do-you-trust-this-application/">
          “你信任这个应用程序吗？”作者Michael Catanzaro </a>
      crypto_verification_private:
        description: >-
          项目生成的软件（如果支持TLS）在发送带有私有信息的HTTP头（如安全Cookie）之前应该执行证书验证。如果软件不使用TLS，请选择“不适用”（N/A）。
      hardened_site:
        description: 建议项目网站，存储库（如果可通过网络访问）和下载站点（如果单独）包括具有非允许值的密钥加固头。
        details: >-
          请注意，GitHub是已知满足的。 https://securityheaders.io/ 等网站可以快速检查。主要头加固包含：内容安全策略（CSP），HTTP严格传输安全性（HSTS），X-Content-Type-Options（“nosniff”），X-Frame-Options和X-XSS-Protection。
      hardening:
        description: 建议在项目生成的软件中使用加固机制，以便软件缺陷不太可能导致安全漏洞。
        details: >-
          加固机制可能包括HTTP头，如内容安全策略（CSP），用于缓解攻击的编译器标志（如-fstack-protector）或用以消除未定义行为的编译器标志。对于此条款的目的，最小权限不被认为是一种加固机制（最小权限是重要的，但是另有条款）。
    '1':
      contribution_requirements:
        description: 关于如何贡献的信息必须包括对可接受的贡献的要求（例如，引用任何所需的编码标准）。
      dco:
        description: >-
          该项目应该有一个合法机制，所有对项目软件做出显著贡献的开发人员都声明他们有合法授权作出这些贡献。最常用且易于实施的方法是使用<a
          href="http://developercertificate.org/">开发者原产地证书（DCO）</a>，用户可以在其提交中添加“signed-off-by”，另外，项目链接到DCO网站。本条款也可以使用贡献者许可协议（CLA）或其他法律机制实现。
        details: >-
          DCO是推荐的机制，因为它易于实现，在源代码中进行跟踪，并且git使用“commit -s”直接支持“签名”功能。更有效的是，项目文件解释了该项目的“签名”手段。
          CLA是一项法律协议，用于定义知识产权许可给组织或项目的条款。捐助者转让协议（CAA）是将知识产权权利转让给另一方的法律协议；项目不必具备CAA，因为CAA增加了潜在贡献者不愿贡献的风险，特别是如果接收者是一个营利性组织。
          <a href="https://www.apache.org/licenses/"> Apache Software
          Foundation CLA（个人贡献者许可证和公司CLA）</a>是CLA的示例，用于确定项目的这些CLA的风险对项目的影响小于其获益。
      governance:
        description: 该项目必须明确定义和记录其项目治理模式（决策方式，包括关键角色）。
        details: >-
          需要有一些成熟的书面方式来作出决定和解决争端。在小项目中，这可能就像“项目拥有者和负责人做所有最终决定”一样简单。有各种治理模式，包括仁慈的独裁者和正式的精英统治；有关详细信息，请参阅<a
          href="http://oss-watch.ac.uk/resources/governancemodels">治理模式</a>。集中式（例如，单一维护者）和分散式（例如，组维护者）方法都已经在项目中成功使用。治理信息不需要记录创建项目分支的可能性，因为对于FLOSS项目来说总是可能的。
      code_of_conduct:
        description: 该项目必须采取行为守则，并将其发布在标准的位置。
        details: >-
          项目可能能够提高社区的文明程度，并通过采取行为守则来规定对可接受的行为的期望。这可以帮助在发生问题之前避免问题，并使项目成为更加欢迎的地方来鼓励贡献。这应该只关注项目社区/工作场所的行为。行为规范的示例是<a
          href="http://contributor-covenant.org/">贡献者约定行为准则</a>和Linux内核<a
          href =“https://www.kernel.org/doc/html/latest/process/code-of-conflict.html">代码冲突</a>。
      roles_responsibilities:
        description: >-
          该项目必须明确定义和公开记录项目中的关键角色及其职责，包括这些角色必须执行的任务。必须清楚指出谁是什么角色，尽管这可能没有以相同的方式记录下来。
        details: <a href="#governance">治理</a>和角色和职责的文档可以在一个地方。
      access_continuity:
        description: >-
          如果任何一个开发者丧失工作能力或丧生，该项目必须能够继续保持最小的中断。特别是，在确认个人无行为能力或死亡的一周内，项目必须能够创建和关闭问题，接受提议的更改和发布软件版本。这可以通过确保其他人有任何必要的密钥，密码和合法权利来继续该项目。运行FLOSS项目的个人可以通过在锁箱中提供密钥，并提供任何所需的合法权利（例如DNS名称）来实现。
      bus_factor:
        description: 项目必须具有2个或更多的“公交车因子”。
        details: >-
          “公交车系数”（又名“卡车因子”）是指最少数量的项目成员，如果突然离开项目（“被公交车撞了”），项目会由于缺乏具备知识的或有能力的人员而暂停。
          <a href="https://github.com/mtov/truck-factor">卡车因子</a>
          工具可以对GitHub上的项目进行估计。有关详细信息，请参阅Cosentino等人的<a href="https://www.researchgate.net/publication/272824568_assessing_the_bus_factor_of_git_repositories">评估Git存储库的卡车因子</a>。
      documentation_roadmap:
        description: 该项目必须有一个文档化的路线图，描述项目打算做什么，至少在下一年做什么。
        details: 项目可能没有实现路线图，没关系。路线图的目的是帮助潜在的用户和贡献者了解项目的预期方向。它不需要特别详细。
      documentation_architecture:
        description: 该项目必须包括项目生成的软件的架构（也称为高级别设计）的文档。如果项目不产生软件，请选择“不适用”（N/A）。
        details: 软件架构解释了程序的基本结构，即程序的主要组件，它们之间的关系以及这些组件和关系的关键属性。
      documentation_security:
        description: 该项目必须书面记录用户从项目生成的软件的安全性上可以获得和不能指望的内容（其“安全需求”）。
        details: 这些是软件意图满足的安全需求。
      documentation_quick_start:
        description: 该项目必须为新用户提供“快速启动”指南，以帮助他们快速使用该软件。
        details: 这个想法是向用户展示如何入门，使软件完全可以做事情。这对于潜在用户是至关重要的。
      documentation_current:
        description: >-
          项目必须努力使文档与当前版本的项目结果（包括项目生成的软件）保持一致。任何<em>已知的</em>文档缺陷使其不一致必须修正。如果文档基本是最新的，但是错误地包括一些不再是真实的旧信息，那么将其视为缺陷，然后像往常一样进行跟踪和修复。
        details: >-
          该文档可以包括有关软件版本之间的差异或更改的信息，与/或链接到旧版本的文档。这个条款的意图在于努力保持文档的一致性，而不是文档必须完美。
      documentation_achievements:
        description: 项目存储代码库首页和/或网站必须在获得成就的48小时内标识并超链接任何成就，包括此最佳实践徽章。
        details: >-
          一个成就是项目致力于满足的任何外部条款，包括徽章。该信息不需要在项目网站首页上。使用GitHub的项目可以通过将其添加到README文件中，将成果放在存储代码库首页。
      accessibility_best_practices:
        description: 该项目（项目网站和项目成果）都应遵循无障碍最佳做法，使残疾人仍然可以参与项目，并在合理的情况下使用项目成果。
        details: |-
          对于Web应用程序，请参阅 <a href="https://www.w3.org/TR/WCAG20/">Web 内容无障碍指导 (WCAG 2.0，英文)</a> 以及其支持文档 <a href="https://www.w3.org/TR/UNDERSTANDING-WCAG20/Overview.html">理解 WCAG 2.0（英文）</a>；或者 <a href="https://www.w3.org/standards/webdesign/accessibility">W3C 无障碍信息（英文）</a>. 图形界面（GUI）应用考虑使用环境特定的无障碍指导（例如 <a href="https://developer.gnome.org/accessibility-devel-guide/stable/">Gnome</a>, <a href="https://accessibility.kde.org/">KDE</a>, <a href="http://docs.xfce.org/xfce/xfce4-settings/accessibility">XFCE</a>, <a href="https://developer.android.com/guide/topics/ui/accessibility/">Android</a>, <a href="https://developer.apple.com/accessibility/ios/">iOS</a>, <a href="http://www.apple.com/accessibility/osx/voiceover/">Mac</a>, 以及 <a href="https://msdn.microsoft.com/en-us/windows/uwp/accessibility/accessibility-overview">Windows</a>). 一些TUI应用 (例如，`ncurses` 程序) 可以做一些特定的工作，增强可访问性（例如，`alpine` 的 `force-arrow-cursor` 设置）。多数命令行应用没有特别的无障碍设置。本条款经常是不涉及（N/A），例如，对于组件库。以下是一些要采取的行动或需要考虑的问题的例子： <ul> <li>提供非文字内容的文字替代，以便于转换为其他需要的格式，如大字体、盲文、语音、符号或者简单文字（ <a href="https://www.w3.org/TR/UNDERSTANDING-WCAG20/text-equiv.html">WCAG 2.0 指导 1.1 （英文）</a>)
          <li>颜色不被用作传达信息，指示动作，提示响应或区分视觉元素的唯一视觉方式。 (
            <a href="https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-without-color.html">WCAG 2.0 指导 1.4.1（英文）</a>)
          <li>文本和文字图像的视觉呈现对比度至少为4.5：1，除了大文本，次要文本和标识符之外。 (
            <a href="https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html">WCAG 2.0 指导 1.4.3（英文）</a>)
          <li>使用键盘可访问所有功能 (WCAG 指导 2.1) <li>图形界面应用（GUI）或者Web应用在目标平台上，应该至少使用一种屏幕阅读器测试（例如，NVDA；Jaws；Windows上的WindowEyes；Mac & iOS上的VoiceOver；Linux/BSD上的Orca；Android上的TalkBack）。TUI程序可以减少过度渲染以防止屏幕阅读器的冗余读取。
          </ul>
      internationalization:
        description: >-
          该项目产生的软件应该被国际化，以便为目标受众的文化，地区或语言进行简单的本地化。如果国际化（i18n）不适用（例如，该软件不会生成针对最终用户的文本，并且不排序可读文本），请选择“不适用”（N/A）。
        details: >-
          本地化“是指适应产品，应用或文档内容以满足特定目标市场（语言环境）的语言，文化和其他要求。国际化是“设计和开发产品，应用或文档内容，使不同文化，地区或语言的目标受众更容易本地化”。
          （请参阅<a href="https://www.w3.org/International/questions/qa-i18n">
          W3C的“本地化与国际化”</a>）。软件只需通过国际化即可达到此标准。不需要另一种特定语言的本地化，因为一旦软件已被国际化，其他人就可以从事本地化。
      sites_password_security:
        description: >-
          如果项目站点（网站，存储库和下载URL）存储用于外部用户认证的密码，则必须使用密钥拉伸（迭代）算法将密码存储为具有每用户盐值的迭代散列（例如，PBKDF2，Bcrypt或Scrypt）。如果项目站点不存储密码，请选择“不适用”（N/A）。
        details: >-
          请注意，使用<a href="https://help.github.com/articles/github-security/">
          GitHub </a>符合此条款。此条款仅适用于用于外部用户认证到项目站点的密码。如果项目站点必须登录到其他站点，则可能需要为此目的存储密码（因为使用像Bcrypt这样的算法会使这些密码无效）。本条款将
          crypto_password_storage 条款应用于项目站点，类似于sites_https条款。
      maintenance_or_update:
        description: >-
          该项目必须维护最常用的旧版本的产品<em>或</em>提供较新版本的升级路径。如果升级路径很困难，项目必须记录如何执行升级（例如，给出更改的接口描述和详细的建议步骤以帮助升级）。
      report_tracker:
        description: 项目必须使用问题跟踪器来跟踪每个问题。
      vulnerability_report_credit:
        description: >-
          除了要求匿名的报告者外，该项目必须对过去12个月内解决的所有漏洞报告的报告者表示感谢。如果过去12个月没有修复漏洞，请选择“不适用”（N/A）。
      vulnerability_response_process:
        description: 该项目必须有一个书面的流程来响应漏洞报告。
        details: >-
          这与security_report_process有很强的相关性，它需要有一个书面的流程来报告漏洞。它还涉及到spam_report_response，它需要在一定时间内响应漏洞报告。
      coding_standards:
        description: 该项目必须确定其使用的主要语言的具体编码风格指南，并要求贡献一般情况下符合此要求。
        details: >-
          在大多数情况下，这是通过参考一些现有的风格指南来完成的，可能列出差异。这些风格指南可以包括提高可读性的方法和减少缺陷可能性（包括漏洞）的方法。许多编程语言有一个或多个广泛使用的风格指南。样式指南的示例包括<a
          href="https://github.com/google/styleguide"> Google风格指南（英文）</a>和<a
          href="https://www.securecoding.cert.org/"> SEI CERT编码标准（英文）</a>。
      coding_standards_enforced:
        description: 如果至少有一个FLOSS工具可以应用于所选择的语言，项目必须自动执行其选定的编码风格。
        details: >-
          这可以使用静态分析工具和/或通过代码重新格式化强制代码实现。在许多情况下，工具配置包含在项目的存储库中（因为不同的项目可能会选择不同的配置）。项目可以允许风格例外（通常会）；在发生例外的情况下（应该很少），它们必须在其位置的代码中记录在案，以便可以对这些例外进行检视，并使工具能够在将来自动处理它们。这些工具的例子包括ESLint（JavaScript）和Rubocop（Ruby）。
      build_standard_variables:
        description: >-
          本地二进制文件的构建系统必须遵守传递给它们的相关编译器和链接器（环境）变量（例如CC，CFLAGS，CXX，CXXFLAGS和LDFLAGS），并将它们传递给编译器和链接器。构建系统可以使用附加标志来扩展它们，但不能简单地用自己的替换提供的值。如果没有生成本地二进制文件，请选择“不适用”（N/A）。
        details: >-
          应该很容易启用特殊的构建功能，如地址消毒剂（Address Sanitizer，ASAN），或符合发布加固最佳实践（例如，通过轻松打开编译器标志来实现）。
      build_preserve_debug:
        description: >-
          构建和安装系统在在相关标志中要求时，应该保留调试信息（例如，“install -s”未被使用）。如果没有构建或安装系统（例如典型的JavaScript库），请选择“不适用”（N/A）。
        details: >-
          例如，如果使用这些语言，则应该设置CFLAGS（C）或CXXFLAGS（C ++）创建相关的调试信息，并且在安装过程中不应该剥离它们。支持和分析时，需要调试信息，也可用于测量编译二进制文件中加固特性的存在。
      build_non_recursive:
        description: >-
          如果子目录中存在交叉依赖关系，则由项目生成的软件的构建系统必须不能递归地构建子目录。如果没有构建或安装系统（例如典型的JavaScript库），请选择“不适用”（N/A）。
        details: >-
          项目构建系统的内部依赖关系信息需要准确，否则，对项目的更改可能无法正确构建。不正确的构建可能会导致缺陷（包括漏洞）。大型构建系统中的常见错误是使用“递归构建”或“递归生成”，即包含源文件的子目录的层次结构，其中每个子目录都是独立构建的。除非每个子目录完全独立，否则这是一个错误，因为依赖关系信息不正确。
      build_repeatable:
        description: >-
          该项目必须能够重复从源代码文件生成的过程，并获得完全相同的比特位结果。如果没有发生构建（例如，直接使用源代码而不是编译使用的脚本语言），请选择“不适用”（N/A）。
        details: >-
          GCC和clang用户可能会发现-frandom-seed选项有用；在某些情况下，这可以通过强制某种排序来解决。更多建议可以在<a
          href="https://reproducible-builds.org/">可重复构建（英文）</a>站点找到。
      installation_common:
        description: 该项目必须提供一种使用常用惯例轻松安装和卸载由项目生成的软件的方法。
        details: >-
          示例包括使用软件包管理器（在系统或语言级别），“make install/uninstall”（支持DESTDIR），标准格式的容器或标准格式的虚拟机映像。安装和卸载过程（例如，打包）可以由第三方FLOSS软件实现。
      installation_standard_variables:
        description: >-
          最终用户的安装系统必须遵守用于在安装时选择构建工件写入位置的标准约定。例如，如果在POSIX系统上安装文件，它必须遵守DESTDIR环境变量。如果没有安装系统或没有标准惯例，请选择“不适用”（N/A）。
      installation_development_quick:
        description: >-
          该项目必须为潜在开发人员提供一种快速安装所有项目成果和支持环境所必需的环境，包括测试套件和测试环境。必须通过常规惯例执行。
        details: >-
          可以使用生成的容器和/或安装脚本来实现。外部依赖关系一般通过调用系统和/或语言包管理器（根据 external_dependencies
          条款）进行安装。
      external_dependencies:
        description: 项目必须以计算机可处理的方式列出外部依赖关系。
        details: >-
          通常这是使用包管理器和/或构建系统的约定完成的。请注意，这有助于实施<a href="#installation_development_quick">
          installation_development_quick </a>。
      dependency_monitoring:
        description: 项目必须监视或定期检查其外部依赖（包括便利副本）以检测已知的漏洞，并修复可利用的漏洞或将其验证为不可利用的漏洞。
        details: >-
          这可以使用来源分析器/依赖关系检查工具来完成，例如<a href="https://www.owasp.org/index.php/OWASP_Dependency_Check">
          OWASP的依赖关系检查</a>，<a href =“ https://www.sonatype.com/nexus-auditor">SonaType's
          Nexus Auditor </a>，<a href="https://www.blackducksoftware.com/products/protex">
          Black Duck's Protex</a> ，<a href="http://www.protecode.com/">
          Synopsys的Protecode </a>和<a href="https://github.com/rubysec/bundler-audit">
          Bundler-audit （适用于Ruby）</a>。一些包管理器也包括这类机制。如果组件的漏洞不能被利用，这是可以接受的，但这种分析是困难的，有时更新或修复该部件更容易。
      updateable_reused_components:
        description: |-
          该项目必须满足下述情况之一：
          <ol>
          <li>可以轻松识别和更新重用的外部维护组件; <strong>或</strong> </li>
          <li>使用系统或编程语言提供的标准组件。</li>
          </ol>
          这样，如果在重用的组件中发现了一个漏洞，将容易更新该组件。
        details: >-
          符合这一条款的典型方法是使用系统和编程语言的包管理系统。许多FLOSS程序与“便利库”一起分发，这些库是标准库的本地副本（可能是分支）。一般没问题。但是，如果程序*必须*使用这些本地（分支）副本，则“标准”库的安全更新将使这些附加副本仍然易受攻击。这对于基于云的系统尤其是一个问题；如果云提供商更新他们的“标准”库，但程序不会使用它们，那么这些更新实际上不会有帮助。参见，例如，<a
          href="http://spot.livejournal.com/312320.html">“Chromium：为什么它不在Fedora中作为适当的包”（Tom
          Callaway）</a>。
      interfaces_current:
        description: >-
          该项目应避免使用已弃用或过时的功能和API，如果FLOSS替代品在其使用的技术集合（“技术堆栈”）中以及项目支持的大多数用户中可用（以便用户可以随时访问该替代品）。
      automated_integration_testing:
        description: 必须将自动测试套件应用于至少一个分支的共享代码库的每次签入。该测试套件必须生成关于测试成功或失败的报告。
        details: 这个要求可以被视为test_continuous_integration的一个子集，但是仅仅是测试，而不需要持续集成。
      regression_tests_added50:
        description: 该项目必须为过去六个月内修复的至少50％的错误，在自动化测试套件中添加回归测试。
      test_statement_coverage80:
        description: 如果有至少一个FLOSS工具可以以所选语言度量此条款，该项目的FLOSS自动测试套件必须具有至少80％语句覆盖率。
        details: >-
          许多FLOSS工具可用于度量测试覆盖范围，包括gcov / lcov，Blanket.js，Istanbul和JCov。请注意，满足这个条款并不能保证测试套件是完备的，而不满足该条款则意味着测试套件很差。
      test_policy_mandated:
        description: 该项目必须具有正式的书面策略，一旦添加了主要的新功能，新功能的测试必须被添加到自动测试套件中。
      tests_documented_added:
        description: 该项目必须在其关于变更建议的书面指导中包括要为主要新功能添加测试的策略。
      warnings_strict:
        description: 在实际允许时，项目必须最大限度地严格修复项目生成的软件中的警告。
      implement_secure_design:
        description: >-
          该项目必须实施安全设计原则（来自“know_secure_design”）（如适用）。如果项目不生产软件，请选择“不适用”（N/A）。
        details: >-
          例如，项目结果应该具有故障安全默认值（默认情况下，访问决策应该拒绝，默认情况下项目的安装应该是安全的），也应该有完全的仲裁（每一个可能被限制的访问权限必须被检查，不可绕过）。请注意，在某些情况下，原则会发生冲突，在这种情况下必须做出选择（例如，许多机制使事情更复杂，违反“机制经济”/“保持最简化”的原则）。
      input_validation:
        description: 项目结果必须检查来自潜在不受信任来源的所有输入，以确保它们有效（ *白名单*），如果对数据有限制，则拒绝无效输入。
        details: >-
          请注意，将输入与“不良格式”（*黑名单*）的列表进行比较通常是不够的，因为攻击者通常可以绕过黑名单。例如，数字被转换成内部格式，然后检查它们是否在最小和最大（包括）之间，并且检查文本字符串以确保它们是有效的文本模式（例如，有效的UTF-8，长度，语法等）。一些数据可能需要是“任何东西”（例如，文件上传器），但这些数据通常是罕见的。
      hardening:
        description: 加固机制应该用于项目生产的软件，以便软件缺陷不太可能导致安全漏洞。
        details: >-
          加固机制可能包括HTTP头，如内容安全策略（CSP），用于减轻攻击的编译器标志（如-fstack-protector）或用以消除未定义行为的编译器标志。对于此条款的目的，最小权限不被认为是一种加固机制（最少权限是重要的，但是另有条款）。
      crypto_weaknesses:
        description: >-
          由项目产生的软件中的默认安全机制不得取决于具有已知严重弱点（例如，SHA-1密码散列算法或SSH中的CBC模式）的加密算法或模式。
      crypto_algorithm_agility:
        description: >-
          该项目应该支持多种加密算法，如果一个被破解，用户可以快速切换。普通的对称密钥算法包括AES，Twofish和Serpent。通用密码散列算法的选择包括SHA-2（包括SHA-224，SHA-256，SHA-384和SHA-512）和SHA-3。
      crypto_credential_agility:
        description: >-
          该项目必须支持在与其他信息（如配置文件，数据库和日志）分离的文件中存储身份验证凭据（如密码和动态令牌）以及私有加密密钥，并允许用户更新和替换它们，而无需重新编译代码。如果项目从不处理身份验证凭据和私有加密密钥，请选择“不适用”（N/A）。
      crypto_used_network:
        description: >-
          该项目产生的软件应该支持所有网络通信的安全协议，如SSHv2或更高版本，TLS1.2或更高版本（HTTPS），IPsec，SFTP和SNMPv3。默认情况下，FTP，HTTP，Telnet，SSLv3或更早版本和SSHv1等不安全协议将被禁用，只有在用户专门配置时才启用。如果项目生成的软件不支持网络通信，请选择“不适用”（N/A）。
      crypto_tls12:
        description: >-
          项目生成的软件（如果支持或使用TLS）应该至少支持TLS版本1.2。请注意，TLS的前身称为SSL。如果软件不使用TLS，请选择“不适用”（N/A）。
      crypto_certificate_verification:
        description: >-
          由项目生成的软件必须，如果它支持TLS，则在使用TLS（包括子资源）时默认执行TLS证书验证。如果软件不使用TLS，请选择“不适用”（N
          / A）。
        details: >-
          请注意，不正确的TLS证书验证是一个常见的错误。有关详细信息，请参阅<a href="http://crypto.stanford.edu/~dabo/pubs/abstracts/ssl-client-bugs.html">“世界上最危险的代码：在非浏览器软件中验证SSL证书“，Martin
          Georgiev等人</a>和<a href="https://blogs.gnome.org/mcatanzaro/2016/03/12/do-you-trust-this-application/">
          “你信任这个应用程序吗？”作者Michael Catanzaro </a>
      crypto_verification_private:
        description: >-
          项目生成的软件（如果支持TLS）必须在发送具有私有信息（如安全Cookie）的HTTP头之前执行证书验证。如果软件不使用TLS，请选择“不适用”（N/A）。
      signed_releases:
        description: >-
          该项目必须加密签名旨在广泛使用的项目结果的发布，并且必须有一个书面流程，向用户解释如何获取公共签名密钥并验证签名。这些签名的私钥不得在项目网站上直接向公众发布。如果发行版本不适用于广泛使用，请选择“不适用”（N/A）。
        details: >-
          项目结果包括源代码和适用的任何生成的可交付成果（例如，可执行文件，包和容器）。生成的交付项可以单独签名源代码。可以用签名的git标签实现（使用加密数字签名）。项目可以从git类似的工具分别提供生成的结果，但在这些情况下，单独的结果必须单独签署。
      version_tags_signed:
        description: >-
          建议在版本控制系统中，每个重要版本标签（作为主要版本的一部分的标签，次要版本或修复公开提到的漏洞）都按照<a
          href ="#signed_releases">signed_releases</a>中的要求进行加密签名，并可验证。
      static_analysis_common_vulnerabilities:
        description: >-
          如果至少有一个FLOSS工具能够以所选择的语言实现此条款，则该项目必须至少使用一个具有规则或方式的静态分析工具来查找分析语言或环境中的常见漏洞。
      dynamic_analysis_unsafe:
        description: >-
          <em>如果</em>由项目生成的软件包含使用内存不安全语言编写的软件（例如，C或C ++），<em>则</em>项目必须至少使用一个动态工具（例如，fuzzer或web应用扫描程序）与一种检测缓冲区覆写等内存安全问题的机制组合例行使用。如果项目不生成以内存不安全语言编写的软件，请选择“不适用”（N/A）。
      assurance_case:
        description: >-
          该项目必须提供一个保证案例，证明其满足安全要求。保证案例必须包括：对威胁模型的描述，明确确定信任边界，确定设计原则得到适用，以及常见安全弱点已经被消减。
        details: >-
          一个保证案例是“一个文献记录的证据体系，提供了一个有说服力和有效的论据，指出一组关于系统属性的关键权利要求在给定环境中给定应用程序是充分合理的”（<a
          href ="http://nvlpubs.nist.gov/nistpubs/ir/2009/ir7608.pdf">使用结构化保证案例模型的软件保证，Thomas
          Rhodes等人，NIST机构间报告7608）。信任边界是数据或执行改变其信任级别的边界，例如，典型Web应用程序中的服务器边界。常见做法是列出安全设计原则（例如Saltzer和Schroeer）和常见的实施安全漏洞（例如OWASP前10名或CWE
          / SANS前25名），并显示每个方案如何抵御。 <a href="https://github.com/coreinfrastructure/best-practices-badge/blob/master/doc/security.md">
          BadgeApp保证案例</a>可能是一个有用的例子。本条款与documentation_security，documentation_architecture和implement_secure_design等条款有关。
      achieve_passing:
        description: 项目必须拥有通过徽章。
    '2':
      bus_factor:
        description: 项目必须具有2个或更多的“公交车因子”。
      contributors_unassociated:
        description: 该项目必须至少有两个不相关的重要贡献者。
        details: >-
          如果同一组织（作为雇员或承包商）支付工作费用，并且组织将从项目的结果中受益，则贡献者是相关联的。如果通过其他组织得到财务补助（例如，源自政府或非政府组织，支付给不同组织的科学补助金不会导致捐助者关联），不视为来自同一组织。重要贡献者定义为过去一年对项目做出了不平凡的贡献。一个重要贡献者的良好指标的例子是：编写至少1,000行代码，贡献50个提交或至少提交20页的文档。
      copyright_per_file:
        description: 该项目必须在每个源文件中包含一个版权声明，确定至少一个相关年份和版权所有者。
        details: >-
          这可以通过在每个文件开头附近的注释中加入以下内容：“<tt>Copyright [year this project
          or content started] - [most recent year modified], [project
          founder] and the [project name] contributors.</tt>”
      license_per_file:
        description: >-
          项目必须在每个源文件中包含许可证声明。这可以通过在每个文件开头附近的注释中加入以下内容来实现：<a href="https://spdx.org/using-spdx#identifiers"><tt>
          SPDX-License-Identifier: [SPDX license expression for
          project]</tt></a>。
        details: >-
          这可以通过在自然语言中包含许可证标识来完成。该项目还可以包括完整许可证文本，或者指向许可证文本的稳定URL。请注意，license_location条款要求项目许可证在标准位置。有关SPDX许可证表达式的更多信息，请参阅<a
          href="https://github.com/david-a-wheeler/spdx-tutorial">SPDX教程</a>。请注意与<a
          href="#copyright_per_file"> copyright_per_file </a>的关系，其内容通常在许可证信息之前。
      repo_distributed:
        description: 必须使用通用的分布式版本控制软件（例如，git，mercurial）作为项目的源代码存储库。
      small_tasks:
        description: 该项目必须清楚地识别新的或临时贡献者可以执行的小型任务。
        details: >-
          此标识通常通过在项目使用的一个或多个标签的问题跟踪器中标记所选问题来完成，例如<a href="http://up-for-grabs.net/#/">
          up- for-grabs </a>，<a href="http://www.firsttimersonly.com/">仅限第一时间</a>，“小修复”，微任务或IdealFirstBug。这些新任务不需要添加功能；他们可以改进文档，添加测试用例或其他有助于项目的内容，并帮助贡献者更了解项目。
      require_2FA:
        description: >-
          项目必须要求开发人员使用双因素身份验证（2FA）来更改中央存储库或访问敏感数据（如私密漏洞报告）。这种2FA机制可以使用没有密码学机制的方案，如SMS（短消息），尽管不推荐。
      secure_2FA:
        description: >-
          项目的双因素身份认证（2FA）应该使用加密机制来防止仿冒。基于短消息服务（SMS）的2FA本身不符合此标准，因为它不被加密。
        details: >-
          满足此条款的2FA机制将是一种基于时间的一次性密码（TOTP）应用程序，可自动生成在一段时间后更改的验证码。请注意，<a
          href="https://help.github.com/articles/configuring-two-factor-authentication-via-a-totp-mobile-app/">
          GitHub支持TOTP </a>。
      code_review_standards:
        description: 该项目必须记录其代码检视需求，包括代码检视是如何进行的，必须检查的内容以及哪些是可接纳的内容。
        details: >-
          另请参阅<a href="#two_person_review"> two_person_review
          </a>和contribution_requirements 条款。
      two_person_review:
        description: >-
          该项目必须至少有50％的修改（作者之外的人提出的）在发布之前审查，以确定是否是一个有价值的修改，并且没有已知的问题，会反对其包含
      build_reproducible:
        description: >-
          该项目必须具有<a href="https://reproducible-builds.org/">可重复构建</a>。如果没有发生构建（例如，直接使用源代码而不是编译的脚本语言），请选择“不适用”（N/A）。
        details: >-
          可重复的构建意味着多方可以独立地重做从源文件生成信息的过程，并获得每比特完全相同的结果。在某些情况下，这可以通过强制某种排序来解决。
          JavaScript开发人员可能会考虑使用npm shrinkwrap和webpack的OccurenceOrderPlugin。
          GCC和clang用户可能会发现-frandom-seed选项有用。通常可以通过指定可用于重新构建的特定容器或虚拟机的加密散列来为外部方定义构建环境（包括工具集）。
          <a href="https://reproducible-builds.org/docs/">可重复构建项目具有文档</a>指导如何执行此操作。
      test_invocation:
        description: 测试套件必须以该语言的标准方式进行调用。
      test_continuous_integration:
        description: 该项目必须实施持续集成，将新的或更改的代码经常集成到中央代码库中，并对结果进行自动化测试。
        details: 在大多数情况下，这意味着每个在项目上全职工作的开发人员至少每天都会整合。
      test_statement_coverage90:
        description: 如果有至少一个FLOSS工具可以以所选语言度量此条款，该项目的FLOSS自动测试套件必须具有至少90％语句覆盖率。
      test_branch_coverage80:
        description: 如果有至少一个FLOSS工具可以以所选语言度量此条款，该项目的FLOSS自动测试套件必须具有至少80％分支覆盖率。
      crypto_used_network:
        description: >-
          项目生成的软件必须支持所有网络通信的安全协议，如SSHv2或更高版本，TLS1.2或更高版本（HTTPS），IPsec，SFTP和SNMPv3。默认情况下，FTP，HTTP，Telnet，SSLv3或更早版本以及SSHv1等不安全协议必须被禁用，只有在用户专门配置时才启用。如果项目生成的软件不支持网络通信，请选择“不适用”（N/A）。
      crypto_tls12:
        description: >-
          由项目生成的软件必须，如果支持或使用TLS，至少支持TLS版本1.2。请注意，TLS的前身称为SSL。如果软件不使用TLS，请选择“不适用”（N/A）。
      hardened_site:
        description: 项目网站，存储库（如果可通过网络访问）和下载站点（如果单独）必须包括具有非允许值的密钥加固头。
        details: >-
          请注意，GitHub是已知满足的。 https://securityheaders.io/ 等网站可以快速查看。主要头加固包含：内容安全策略（CSP），HTTP严格传输安全性（HSTS），X-Content-Type-Options（“nosniff”），X-Frame-Options和X-XSS-Protection。
      security_review:
        description: 该项目必须在过去5年内进行安全审查。此审查必须考虑安全需求和安全边界。
        details: >-
          这可以由项目成员完成和/或独立评估。此评估可能由静态和动态分析工具支持，但还必须进行人工审查，以确定工具无法检测到的问题（特别是设计问题）。
      hardening:
        description: 加固机制必须用于项目生产的软件，以便软件缺陷不太可能导致安全漏洞。
      dynamic_analysis:
        description: 必须在发布之前，至少将一个动态分析工具应用于软件任何候选发布的主要生产版本。
      dynamic_analysis_enable_assertions:
        description: 项目应该在其生成的软件中包含许多运行时断言，并在动态分析期间检查这些断言。
      achieve_silver:
        description: 该项目必须拥有银级徽章。
  static_pages:
    home:
      badge_program: CII 最佳实践徽章计划
      get_your_badge: 马上获取徽章！
      p1_html: |-
        The <a href="https://www.linuxfoundation.org/">Linux 基金会 (LF)</a>
        <a href="https://www.coreinfrastructure.org/">核心基础设施计划
        (CII)</a>
        最佳实践徽章是自由和开放源代码软件(FLOSS)项目展示自己遵循安全最佳实践的>途径。
        项目可以使用本Web应用，自愿、免费的自助认证，来阐述如何遵循每项最佳实践>。
        The CII 最佳实践徽章受到GitHub上众多可获得的徽章系统的启发。徽章的目标用 户将能够
        快速评估哪些FLOSS项目遵循最佳实践，也将更容易地构建高质量的安全软件。
      p2_html: |-
        关于CII 最佳实践徽章计划的更多信息，
        包括背景以及
        <a href='https://github.com/coreinfrastructure/best-practices-badge/blob/master/doc/criteria.md'>标准</a>, 可以访问
        <a href='https://github.com/coreinfrastructure/best-practices-badge'>GitHub 项目</a>.
        <a href="/zh-CN/project_stats">项目统计数据</a> 和
        <a href="/zh-CN/criteria">标准统计数据</a> 也同时提供。
        <a href="/zh-CN/projects">项目页面</a> 展示所有参与的项目，
        并支持查询（例如，你可以看到
        <a href="/zh-CN/projects?gteq=100">已经获取通过徽章的项目</a>)。
        你也可以查询
        <a href='/zh-CN/projects/1'>一个示例（我们是如何获取自己的徽章的）</a>。
      p3_html: |-
        <em>隐私和法律问题</em>：
        请访问我们的
        <a href="https://www.linuxfoundation.org/privacy">隐私策略</a>
        和
        <a href="https://www.linuxfoundation.org/terms">使用条款</a>.
        所有公开可获得的非代码内容使用
        <a href="https://creativecommons.org/licenses/by/3.0/">知识共享署名许可>证版本3.0 (C
        C-BY-3.0)</a>及其后续版本发布；
        新的非代码内容
        使用CC-BY 版本 3.0 或者更高 (CC-BY-3.0+)。
        如果集体引用，或不另外注明，
        请标明出处为CII最佳实践徽章贡献者。
      check_us_out:
      share_header_html:
      twitter:
      reddit:
      facebook:
      linkedin:
      googleplus:
      email:
    criteria:
      criteria: 条款
      detailed_criteria_on_github: 详细的条款在GitHub网站。
      current_criteria: 当前条款数量：%{active}（活跃）+ %{future}（未来）= %{total}（总计）。
      criteria_must_should_suggested: 在活跃条款中，有%{must}个必须，%{should}
        个应该和%{suggested}个建议条款。
      criteria_na_met_details: >-
        在活跃条款中，%{na_allowed}允许N/A，%{met_url_required}在满足时需要URL，而%{details_present}在其描述中具有详细信息。
      project_counts: 有%{projects}个项目条目; %{passing}个已经通过，%{in_progress}个正在进行中。
      project_stats_html: 您可以在<a href="/project_stats">项目统计信息页面</a>查看有关项目的统计信息。
      level: 等级
      must: 必须
      should: 应该
      suggested: 建议
      total_active: 总有效
      allow_na: 允许N/A
      require_url: 需要网址
      details: 包括细节
      future: 未来
      new_this_level: 在这个级别的新的
      met_justification_required: 需要满足理由
      met_justification_or_url_required: 满足理由或需要URL
    cookies:
      cookies_header:
      cookies_info_html:
  headings:
    Accessibility and internationalization: 无障碍和国际化
    Analysis: 分析
    Automated test suite: 自动测试套件
    Basic project website content: 基本项目网站内容
    Basics: 基本
    Bug-reporting process: 错误报告流程
    Change Control: 变更控制
    Coding standards: 编码标准
    Documentation: 文档
    Dynamic code analysis: 动态代码分析
    Externally-maintained components: 外部维护的组件
    Future: 未来
    future: 未来
    Installation system: 安装系统
    New functionality testing: 新功能测试
    OSS License: OSS许可证
    Other: 其他
    Other security issues: 其他安全问题
    Previous versions: 之前的版本
    Project oversight: 项目监督
    Public version-controlled source repository: 公开的版本控制的源代码存储库
    Publicly known vulnerabilities fixed: 修正公开的漏洞
    Quality: 质量
    Release notes: 发行说明
    Reporting: 报告
    Secure development knowledge: 安全开发知识
    Secure release: 安全发布
    Secured delivery against man-in-the-middle (MITM) attacks: 安全交付防御中间人（MITM）的攻击
    Security: 安全
    Static code analysis: 静态代码分析
    Unique version numbering: 唯一版本编号
    Use basic good cryptographic practices: 使用基础的良好加密实践
    Vulnerability report process: 漏洞报告流程
    Warning flags: 警告标志
    Working build system: 可工作的构建系统
    Identification: 识别
    Prerequisites: 先决条件
    FLOSS license: FLOSS许可证
  last_entry: 最后翻译条目
  admin_only: 仅限管理员。
  criterion_status:
    Met: |2-
      完成
    Unmet: |2-
      不完整
    NA: N/A
  error_messages:
    need_home_page_or_url: 至少需要一个主页或存储库URL
    form_contains:
      one: 该表单包含1个错误。
      other: 该表单包含%{count}个错误。
      few: 该表单包含%{count}个错误。
      many: 该表单包含%{count}个错误。
    comma_separated_list: " 必须是以逗号分隔的名称列表"
    begin_with_cpe: " 必须以“cpe:”开头"
    not_an_email: " 不是电子邮件"
    known_bad_password: " 是一个众所周知的（坏）密码"
    valid_text: " 必须是有效的UTF-8编码，没有无效的控制字符"
    url_message: " 必须以http:或https:开头，并使用有限的字符集"